# **LeetCode Mastery: O Guia Definitivo para Engenheiros de Software**

## **Sumário**

1. [Introdução: Por Que Dominar o LeetCode Vai Além das Entrevistas](#introdução-por-que-dominar-o-leetcode-vai-além-das-entrevistas)
2. [A Abordagem Estratégica: Padrões, Não Problemas](#a-abordagem-estratégica-padrões-não-problemas)
3. [Sliding Window: O Padrão Mais Subestimado e Poderoso](#sliding-window-o-padrão-mais-subestimado-e-poderoso)
4. [Two Pointers: A Técnica Mais Versátil em Arrays e Strings](#two-pointers-a-técnica-mais-versátil-em-arrays-e-strings)
5. [Hash Maps: O Superpoder dos Problemas de Frequência e Lookup](#hash-maps-o-superpoder-dos-problemas-de-frequência-e-lookup)
6. [Prefix Sum & Difference Arrays: A Arte de Evitar Repetição](#prefix-sum--difference-arrays-a-arte-de-evitar-repetição)
7. [Binary Search: Cortando Pela Metade, Pensando com Precisão](#binary-search-cortando-pela-metade-pensando-com-precisão)
8. [Depth-First Search & Backtracking: Explorando Todas as Possibilidades](#depth-first-search--backtracking-explorando-todas-as-possibilidades)
9. [Breadth-First Search & Graph Traversal: Caminho Mais Curto e Além](#breadth-first-search--graph-traversal-caminho-mais-curto-e-além)
10. [Dynamic Programming: Construindo Soluções Incrementais](#dynamic-programming-construindo-soluções-incrementais)
11. [Greedy Algorithms: Otimizando Passo a Passo](#greedy-algorithms-otimizando-passo-a-passo)
12. [Estruturas Avançadas: Trie, Union Find e Segment Trees](#estruturas-avançadas-trie-union-find-e-segment-trees)
13. [Plano de Estudo de 12 Semanas: Da Fundação à Maestria](#plano-de-estudo-de-12-semanas-da-fundação-à-maestria)
14. [150 Problemas Essenciais: O Mapa para o Domínio](#150-problemas-essenciais-o-mapa-para-o-domínio)
15. [Framework de Resolução: Da Leitura à Solução Otimizada](#framework-de-resolução-da-leitura-à-solução-otimizada)
16. [Preparação para Entrevistas: Simulação, Comunicação e Performance](#preparação-para-entrevistas-simulação-comunicação-e-performance)

---

# **Introdução: Por Que Dominar o LeetCode Vai Além das Entrevistas**

## **O Novo Perfil do Engenheiro de Software**

No passado, saber programar e entregar features era suficiente. Hoje, o cenário mudou radicalmente. Com grandes empresas como Google, Meta, Amazon e startups exigindo **pensamento algorítmico afiado**, dominar estruturas de dados e técnicas de resolução de problemas deixou de ser algo "acadêmico" e passou a ser um **diferencial competitivo real** — mesmo para devs sêniors.

Se você já trabalha há anos com desenvolvimento, pode parecer que resolver problemas no LeetCode não tem relação direta com sua rotina. Mas o que está por trás do LeetCode **afina seu raciocínio, aumenta sua velocidade mental e melhora sua capacidade de pensar em sistemas escaláveis e eficientes**.

> "O verdadeiro valor do LeetCode não é passar em entrevistas, é treinar seu cérebro para resolver problemas complexos com elegância."

## **O Que É o LeetCode (de Verdade)?**

LeetCode é uma plataforma de resolução de problemas algorítmicos. Mas, na essência, ele é:

- Um **laboratório de raciocínio computacional**
- Um **campo de treino mental**
- Uma **simulação prática de entrevistas técnicas**
- Um **guia para fortalecer sua base em Computer Science**

Você pode encarar o LeetCode como um "jogo mental de programadores" — e quanto mais você entende as regras e os padrões, mais rápido você sobe de nível.

## **O Mito da Quantidade**

> "Preciso resolver 1000 problemas?"

Não. **Não é sobre quantidade, é sobre qualidade e repetição estratégica.**

É muito mais eficiente resolver **150 problemas bem escolhidos**, entendendo profundamente os padrões por trás, do que fazer 500 no modo automático.

### **Estudo Revelador**

Um estudo com 500 desenvolvedores mostrou que aqueles que focaram em **compreender padrões e revisitar problemas** tiveram 3x mais sucesso em entrevistas do que os que simplesmente acumularam soluções.

## **Os Quatro Pilares da Maestria no LeetCode**

### **1. Padrões**

Você não aprende resolvendo problemas. Você aprende **reconhecendo padrões** que se repetem neles: sliding window, backtracking, DP com tabulação, busca binária na resposta, etc.

### **2. Processos**

Resolver bem um problema envolve um processo sistemático:
1. Entender bem o problema
2. Identificar possíveis abordagens
3. Esboçar soluções
4. Otimizar
5. Explicar com clareza

### **3. Prática Deliberada**

Não basta só praticar — tem que praticar com foco. A prática deliberada envolve:
- Resolver sem olhar a solução
- Revisar os erros
- Refazer problemas-chave
- Aplicar repetição espaçada

### **4. Metacognição**

Os melhores solucionadores de problemas não só resolvem, mas **entendem como pensam**. Eles:
- Verbalizam seu raciocínio
- Identificam onde travaram
- Desenvolvem atalhos mentais
- Reconhecem padrões em seu próprio pensamento

## **Como Usar Este Guia**

Este guia é dividido por **técnicas**, com capítulos práticos, mapas mentais e exemplos reais. Você pode:

- Estudar um capítulo por semana
- Praticar os problemas sugeridos com a metodologia proposta
- Usar o plano de revisão e progresso (Capítulo 13)
- Consultar a árvore de decisão quando estiver preso (Capítulo 15)

**Dica:** imprima os checklists, use marca-texto e anote suas dúvidas. A ideia aqui não é só ler, é **internalizar**.

## **Quem Vai Se Beneficiar Desse Guia**

Este guia foi escrito para:

- Desenvolvedores com experiência prática (3+ anos) que querem destravar entrevistas
- Devs sêniors que querem **afiar a mente algorítmica**
- Estudantes buscando um **plano inteligente de estudo**
- Qualquer pessoa que **não quer só "passar em entrevista", mas quer pensar melhor como engenheiro**

## **Comece com a mentalidade certa**

> "Você não precisa ser o melhor programador do mundo. Só precisa ter um método que funcione e constância suficiente pra seguir com ele."

Você já tem anos de experiência? Ótimo. Isso vai acelerar muito sua curva. Mas para realmente dominar o LeetCode, é preciso voltar a ser iniciante em certos pontos. Humildade, foco e método — esse é o combo vencedor.

---

# **A Abordagem Estratégica: Padrões, Não Problemas**

## **A Matriz de Padrões vs. Dificuldade**

Aqui está o segredo que mudará sua mentalidade sobre o LeetCode: **cada problema é uma variação de um padrão fundamental**. Abaixo, mapeamos os principais padrões e sua distribuição por nível de dificuldade:

| Padrão | Fácil | Médio | Difícil | Total | Importância |
|--------|-------|-------|---------|-------|-------------|
| Sliding Window | 4 | 12 | 7 | 23 | ⭐⭐⭐⭐⭐ |
| Two Pointers | 11 | 15 | 5 | 31 | ⭐⭐⭐⭐⭐ |
| Hash Maps | 15 | 20 | 5 | 40 | ⭐⭐⭐⭐⭐ |
| Binary Search | 8 | 14 | 7 | 29 | ⭐⭐⭐⭐ |
| DFS/Backtracking | 3 | 19 | 16 | 38 | ⭐⭐⭐⭐⭐ |
| BFS | 1 | 12 | 11 | 24 | ⭐⭐⭐⭐ |
| Dynamic Programming | 5 | 25 | 30 | 60 | ⭐⭐⭐⭐⭐ |
| Prefix Sum | 6 | 8 | 4 | 18 | ⭐⭐⭐ |
| Greedy | 7 | 18 | 9 | 34 | ⭐⭐⭐ |
| Trie | 0 | 7 | 8 | 15 | ⭐⭐⭐ |
| Union Find | 0 | 6 | 8 | 14 | ⭐⭐⭐ |

## **Árvore de Decisão para Escolha de Técnica**

Como decidir qual abordagem usar? Siga este diagrama de fluxo simplificado:

1. **Array/String** → Considere:
   - Subconjuntos contínuos? → **Sliding Window**
   - Pares/movimento em direções opostas? → **Two Pointers**
   - Contagem/frequência? → **Hash Map**
   - Faixa de valores pequena? → **Counting Sort**
   - Operações em intervalos? → **Prefix Sum/Difference Array**
   - Array ordenado ou quase ordenado? → **Binary Search**

2. **Árvore/Grafo** → Considere:
   - Caminho mais curto? → **BFS**
   - Explorar todos os caminhos? → **DFS**
   - Ciclos ou componentes? → **Union Find**
   - Palavras/prefixos? → **Trie**

3. **Otimização com subproblemas** → Considere:
   - Sobreposição de subproblemas? → **Dynamic Programming**
   - Escolha ótima local? → **Greedy**
   - Todas as combinações? → **Backtracking**

## **Spaced Repetition: O Sistema Científico de Revisão**

A repetição espaçada é um método cientificamente comprovado para aumentar a retenção. Para problemas do LeetCode:

1. **Primeira exposição**: Entenda completamente a solução
2. **24 horas depois**: Resolva novamente do zero
3. **3 dias depois**: Nova tentativa
4. **7 dias depois**: Revisão
5. **14 dias depois**: Revisão final

Use um sistema como o Anki ou nossa planilha de acompanhamento (Capítulo 13) para gerenciar este ciclo.

## **A Regra dos 3 Tempos de Resolução**

Para verdadeira proficiência:
1. **Primeira solução**: Entender e implementar
2. **Segunda solução**: Otimizar e melhorar
3. **Terceira solução**: Dominar e explicar

Você só "aprendeu" um problema quando pode explicá-lo claramente para outra pessoa sem consultas.

## **As 4 Fases da Competência em Algoritmos**

1. **Incompetência Inconsciente**: Você não sabe o que não sabe
2. **Incompetência Consciente**: Reconhece o padrão mas ainda não sabe implementar
3. **Competência Consciente**: Implementa com esforço mental
4. **Competência Inconsciente**: Implementa naturalmente, foco na otimização

O objetivo deste guia é levar você até a fase 4 nos padrões fundamentais.

## **Anatomia de uma Resolução de Problema**

1. **Leitura Ativa** (2 min)
   - Identifique as restrições
   - Entenda os exemplos
   - Esclareça os extremos

2. **Brainstorm de Abordagens** (3 min)
   - Identifique o padrão
   - Esboce soluções candidatas
   - Avalie complexidade

3. **Implementação** (15 min)
   - Codifique a solução
   - Teste com exemplos
   - Refine e otimize

4. **Validação** (2 min)
   - Verifique edge cases
   - Analise a complexidade final
   - Explique sua solução

Esta estrutura é essencial tanto para prática quanto para entrevistas reais.

---

# **Sliding Window: O Padrão Mais Subestimado e Poderoso**

## **O Que É o Sliding Window (De Verdade)?**

Sliding Window é uma técnica para **resolver problemas que envolvem subconjuntos contínuos de dados** (como substrings ou subarrays), **otimizando a iteração com um ponteiro que desliza** em vez de usar dois loops aninhados.

Em vez de recalcular tudo a cada passo, você **aproveita os dados já computados e só ajusta o que mudou**.

## **Quando Usar Sliding Window**

Você provavelmente está diante de um problema de Sliding Window quando:

- O input é uma **string ou array**
- A pergunta envolve **uma "janela" contínua**: maior, menor, número de elementos, soma, etc.
- Você precisa **comparar elementos próximos ou sequências contínuas**
- A performance do brute-force (dois loops) não é aceitável (O(n²) → O(n))

## **O Diagrama Mental do Sliding Window**

```
Array: [a, b, c, d, e, f, g, h]
        ↑     ↑
      left   right
```

A janela é o intervalo [left, right]. A cada passo:
1. Expandimos a janela movendo `right`
2. Processamos o elemento em `right`
3. Se necessário, contraímos a janela movendo `left`

## **Tipos de Sliding Window**

### **1. Janela de Tamanho Fixo**

**Exemplo: encontrar a soma máxima de uma subarray de tamanho k**

```python
def max_sum_subarray(nums, k):
    window_sum = sum(nums[:k])
    max_sum = window_sum
    
    for i in range(k, len(nums)):
        window_sum += nums[i] - nums[i - k]  # Add next, remove first
        max_sum = max(max_sum, window_sum)
        
    return max_sum
```

**Insight:** você **não precisa somar tudo de novo**, só ajusta o valor que entrou e saiu da janela.

### **2. Janela de Tamanho Variável**

**Exemplo: encontrar a menor subarray com soma >= target**

```python
def min_subarray_len(target, nums):
    left = 0
    total = 0
    min_len = float('inf')
    
    for right in range(len(nums)):
        total += nums[right]  # Expand window
        
        while total >= target:  # Contract window if condition is met
            min_len = min(min_len, right - left + 1)
            total -= nums[left]
            left += 1
            
    return 0 if min_len == float('inf') else min_len
```

**Insight:** o ponteiro esquerdo só anda **quando a condição for satisfeita**. Isso evita trabalho desnecessário.

## **Padrão Mental: Sliding Window em 5 Passos**

1. **Identifique o tipo:** Tamanho fixo ou variável?
2. **Inicie ponteiros (normalmente left, right)**
3. **Atualize a janela ao mover right**
4. **Condicionalmente mova left**
5. **Mantenha algum tipo de "estado" (soma, set, hash, maxLen, etc.)**

## **Aplicação Avançada: Sliding Window com Hash Map**

Para problemas de strings onde precisamos rastrear frequências, combine Sliding Window com HashMap:

```python
def longest_substring_without_repeating(s):
    char_index = {}  # Maps char to its last seen position
    left = 0
    max_len = 0
    
    for right in range(len(s)):
        # If char already in window, contract the window
        if s[right] in char_index and char_index[s[right]] >= left:
            left = char_index[s[right]] + 1
        
        char_index[s[right]] = right
        max_len = max(max_len, right - left + 1)
        
    return max_len
```

## **Problemas Clássicos no LeetCode**

| **Nome** | **ID** | **Tipo** | **Dificuldade** |
|----------|--------|----------|-----------------|
| Maximum Subarray | #53 | Kadane's Algorithm (variação) | Easy |
| Longest Substring Without Repeating Characters | #3 | Window variável | Medium |
| Minimum Size Subarray Sum | #209 | Window variável | Medium |
| Permutation in String | #567 | Fixo + frequência | Medium |
| Longest Repeating Character Replacement | #424 | Janela com contagem | Medium |
| Max Consecutive Ones III | #1004 | Janela que ignora k zeros | Medium |
| Sliding Window Maximum | #239 | Janela + deque | Hard |

## **Dicas e Armadilhas**

- **Evite recriar estruturas a cada passo.** Use mapas e atualize contagens incrementalmente.
- Em strings, usar `collections.Counter` ou `defaultdict(int)` ajuda muito.
- Quando envolver "sem repetição", pense em set ou dict com frequência.
- Quando envolver "caracteres mais frequentes", mantenha um contador do **caractere dominante**.
- Não se esqueça de atualizar o resultado a cada expansão/contração relevante.

## **Pensando Em Voz Alta: Minimum Window Substring**

*Problema*: Dada uma string S e uma string T, encontre a menor substring em S que contém todos os caracteres de T.

*Abordagem*:
1. Preciso de uma janela de tamanho variável, pois não sei o tamanho da resposta
2. Preciso rastrear frequências dos caracteres (HashMap)
3. A janela é válida quando todos os caracteres de T estão presentes na frequência correta
4. Expando até encontrar uma janela válida, depois contrair o máximo possível

```python
def minWindow(s, t):
    if not t or not s:
        return ""
    
    # Dictionary for counting characters in t
    dict_t = Counter(t)
    required = len(dict_t)
    
    # Left and right pointers
    l, r = 0, 0
    formed = 0  # To keep track of how many char types are matched
    
    # Dictionary for window
    window_counts = {}
    
    # To store result
    ans = float("inf"), None, None
    
    while r < len(s):
        # Expand window
        character = s[r]
        window_counts[character] = window_counts.get(character, 0) + 1
        
        if character in dict_t and window_counts[character] == dict_t[character]:
            formed += 1
            
        # Contract window if valid
        while l <= r and formed == required:
            character = s[l]
            
            # Update result
            if r - l + 1 < ans[0]:
                ans = (r - l + 1, l, r)
                
            # Remove leftmost character
            window_counts[character] -= 1
            if character in dict_t and window_counts[character] < dict_t[character]:
                formed -= 1
                
            l += 1
            
        r += 1
        
    return "" if ans[0] == float("inf") else s[ans[1]:ans[2] + 1]
```

## **Checklist para Sliding Window**

- [ ] Sei diferenciar problemas de janela fixa e variável
- [ ] Entendi o padrão base do Sliding Window
- [ ] Sei integrar HashMap para rastreamento de frequências 
- [ ] Consigo otimizar a atualização de estados (evitando recálculos)
- [ ] Implementei pelo menos 5 variações diferentes do padrão

## **Mini Desafio**

**Problema:** Dado um array de inteiros e um valor k, encontre o número máximo de elementos distintos em qualquer subarray de tamanho k.

**Solução**:
1. Use uma janela de tamanho fixo k
2. Mantenha um HashMap para contar frequências dos elementos
3. Quando uma janela está completa, conte elementos distintos (com frequência > 0)
4. Ao avançar a janela, decremente a frequência do elemento que sai e incremente a do que entra

---

# **Two Pointers: A Técnica Mais Versátil em Arrays e Strings**

## **Por Que Two Pointers Está em Todo Lugar?**

Two Pointers (dois ponteiros) é uma técnica fundamental que resolve **problemas com relações entre elementos** — especialmente quando:

- Os dados estão **ordenados**
- Você quer **reduzir o espaço** (evitar cópias)
- Precisa **comparar pares ou deslocar elementos** em tempo linear
- Quer resolver um problema que envolve **movimento bidirecional**

É, sem exagero, uma das técnicas que mais aparece em entrevistas — **simples de entender, mas poderosa quando combinada com outras**.

## **Visualizando Two Pointers**

```
Array: [a, b, c, d, e, f, g, h]
        ↑                    ↑
      left                 right
```

Os ponteiros podem:
- Iniciar em extremos opostos e se moverem até o centro
- Moverem-se na mesma direção em velocidades diferentes 
- Percorrer arrays diferentes simultaneamente

## **Formatos Clássicos de Two Pointers**

### **1. Pointers Iniciais em Extremidades (Início e Fim)**

Usado para:
- Encontrar pares com soma específica
- Verificar palíndromos
- Problemas de container ou espaço entre índices

**Exemplo: Container With Most Water (LeetCode #11)**

```python
def max_area(height):
    left, right = 0, len(height) - 1
    max_area = 0
    
    while left < right:
        h = min(height[left], height[right])
        max_area = max(max_area, h * (right - left))
        
        if height[left] < height[right]:
            left += 1
        else:
            right -= 1
            
    return max_area
```

**Insight:** os ponteiros se aproximam tentando melhorar a área sem perder a lógica.

### **2. Pointers Indo do Começo Juntos (ou Separados)**

Usado em:
- **Remover duplicatas**
- Merge de arrays
- Comparar strings ou listas
- Move zeroes, reorder arrays, merge lists

**Exemplo: Remove Duplicates from Sorted Array (LeetCode #26)**

```python
def remove_duplicates(nums):
    if not nums:
        return 0
        
    slow = 1
    
    for fast in range(1, len(nums)):
        if nums[fast] != nums[fast - 1]:
            nums[slow] = nums[fast]
            slow += 1
            
    return slow
```

**Insight:** fast explora, slow constrói o resultado.

### **3. Comparando Arrays Diferentes**

Problemas que pedem:
- Interseção
- Subsequência
- Diferença mínima entre arrays

**Exemplo: Merge Sorted Arrays (LeetCode #88)**

```python
def merge(nums1, m, nums2, n):
    p1 = m - 1  # Pointer for nums1
    p2 = n - 1  # Pointer for nums2
    p = m + n - 1  # Pointer for result
    
    # Merge from the end
    while p1 >= 0 and p2 >= 0:
        if nums1[p1] > nums2[p2]:
            nums1[p] = nums1[p1]
            p1 -= 1
        else:
            nums1[p] = nums2[p2]
            p2 -= 1
        p -= 1
    
    # If there are remaining elements in nums2
    while p2 >= 0:
        nums1[p] = nums2[p2]
        p2 -= 1
        p -= 1
```

## **Combinando Two Pointers com Outras Técnicas**

### **Two Pointers + Sorting**

```python
def three_sum(nums):
    nums.sort()  # Sort first
    result = []
    
    for i in range(len(nums) - 2):
        # Skip duplicates
        if i > 0 and nums[i] == nums[i-1]:
            continue
            
        left, right = i + 1, len(nums) - 1
        
        while left < right:
            s = nums[i] + nums[left] + nums[right]
            
            if s < 0:
                left += 1
            elif s > 0:
                right -= 1
            else:
                result.append([nums[i], nums[left], nums[right]])
                
                # Skip duplicates
                while left < right and nums[left] == nums[left+1]:
                    left += 1
                while left < right and nums[right] == nums[right-1]:
                    right -= 1
                    
                left += 1
                right -= 1
                
    return result
```

### **Two Pointers + Sliding Window**

```python
def trap_rain_water(height):
    left, right = 0, len(height) - 1
    left_max = right_max = 0
    result = 0
    
    while left < right:
        if height[left] < height[right]:
            if height[left] >= left_max:
                left_max = height[left]
            else:
                result += left_max - height[left]
            left += 1
        else:
            if height[right] >= right_max:
                right_max = height[right]
            else:
                result += right_max - height[right]
            right -= 1
            
    return result
```

## **Problemas Clássicos no LeetCode**

| **Nome** | **ID** | **Tipo** | **Dificuldade** |
|----------|--------|----------|-----------------|
| Two Sum II - Input array is sorted | #167 | Início + fim | Easy |
| Valid Palindrome | #125 | Extremidades | Easy |
| Remove Duplicates from Sorted Array | #26 | Ponteiros paralelos | Easy |
| Merge Sorted Array | #88 | Dois arrays | Easy |
| 3Sum | #15 | Two pointers dentro de loop | Medium |
| Container With Most Water | #11 | Extremidades | Medium |
| Trapping Rain Water | #42 | Two Pointers + Max | Hard |

## **Template Mental: Two Pointers**

1. Verifique se o input é **ordenado** ou se a ordenação ajudaria
2. Decida se os ponteiros começam juntos ou afastados
3. Mova um ou ambos com base em **alguma condição**
4. Mantenha o objetivo: busca, remoção, interseção, etc.
5. Tente **resolver em tempo O(n)** sempre que possível

## **Dicas e Armadilhas**

- **Arrays ordenados**? Já pense em Two Pointers.
- Combine com Sliding Window para fazer verificações em tempo linear.
- Evite criar novos arrays quando puder sobrescrever com slow.
- Lembre-se: às vezes os ponteiros **não precisam andar ao mesmo tempo**.
- Cuidado com os índices quando os ponteiros se cruzam - use `<=` ou `<` corretamente.

## **Pensando Em Voz Alta: Trapping Rain Water**

*Problema*: Dado um array de alturas, encontre quanto de água pode ser presa após a chuva.

*Insights*:
1. Para cada posição, a água presa depende do mínimo entre o máximo à esquerda e o máximo à direita
2. Posso usar two pointers para explorar o array de ambos os lados
3. A chave é manter o máximo da esquerda e da direita conforme avanço
4. Sempre movimento o ponteiro do lado com menor altura

```python
def trap(height):
    if not height: return 0
    
    left, right = 0, len(height) - 1
    left_max = height[left]
    right_max = height[right]
    result = 0
    
    while left < right:
        # Sempre avançamos o lado mais baixo
        if left_max < right_max:
            left += 1
            # Se encontrarmos uma altura maior, atualizamos left_max
            # Caso contrário, calculamos a água presa
            if height[left] > left_max:
                left_max = height[left]
            else:
                result += left_max - height[left]
        else:
            right -= 1
            if height[right] > right_max:
                right_max = height[right]
            else:
                result += right_max - height[right]
    
    return result
```

## **Checklist de Two Pointers**

- [ ] Entendo as diferentes formas de inicializar e mover ponteiros
- [ ] Sei quando ordenar o array antes de aplicar a técnica
- [ ] Consigo aplicar em problemas de um único array e múltiplos arrays
- [ ] Entendo como tratar ponteiros que precisam pular duplicatas
- [ ] Implementei pelo menos 5 variações diferentes do padrão

## **Mini Desafio**

**Problema:** Dado um array ordenado e um número target, retorne os índices (1-based) de dois números que somam target.

**Input:** [2, 7, 11, 15], target = 9
**Saída:** [1, 2]

**Solução**:
1. Use dois ponteiros, um no início e outro no fim
2. Se a soma for menor que o target, mova o ponteiro da esquerda
3. Se a soma for maior que o target, mova o ponteiro da direita
4. Quando encontrar a soma exata, retorne os índices (lembre-se de +1 para 1-based)

---

# **Hash Maps: O Superpoder dos Problemas de Frequência e Lookup**

## **Por Que Hash Maps São Tão Poderosos?**

Quando um problema envolve:
- Frequência de elementos
- Lookup rápido (em O(1))
- Contar, agrupar ou mapear dados
- Eliminar duplicidade ou encontrar padrões

... **Hash Map (ou dict no Python)** é provavelmente a melhor resposta.

A ideia é **sacrificar memória pra ganhar tempo** — especialmente quando você precisa fazer comparações, buscas ou relações entre dados complexos.

## **Visualizando Hash Maps em Ação**

```
Array: [2, 7, 11, 15]
Target: 9

Hash Map: {
  2 -> 0,  # value -> index
  7 -> 1,
  ...
}

Para o elemento 7: 
  Procuramos (9 - 7) = 2 no mapa
  2 existe no mapa? Sim! Encontramos o par (2, 7)
```

## **Padrões de Uso**

### **1. Frequência de Elementos**

**Exemplo: Majority Element (LeetCode #169)**

```python
from collections import defaultdict

def majority_element(nums):
    count = defaultdict(int)
    
    for num in nums:
        count[num] += 1
        if count[num] > len(nums) // 2:
            return num
```

### **2. Verificar Anagramas**

**Exemplo: Valid Anagram (LeetCode #242)**

```python
from collections import Counter

def is_anagram(s, t):
    return Counter(s) == Counter(t)
```

### **3. Subarray com Soma Alvo (Subarray Sum Equals K #560)**

```python
def subarray_sum(nums, k):
    count = 0
    prefix = 0
    prefix_map = {0: 1}  # Empty subarray
    
    for num in nums:
        prefix += num
        count += prefix_map.get(prefix - k, 0)
        prefix_map[prefix] = prefix_map.get(prefix, 0) + 1
        
    return count
```

**Insight:** guardar os prefixos permite contar subarrays sem precisar iterar todos os inícios possíveis.

## **Tipos de Hash Maps**

### **1. Hash Map de Contagem**

- Mapeia elemento → frequência
- Ideal para: contagem, anagramas, frequência de elementos

```python
# Python 3.6+
counter = {}
for item in array:
    counter[item] = counter.get(item, 0) + 1

# Alternativa com defaultdict
from collections import defaultdict
counter = defaultdict(int)
for item in array:
    counter[item] += 1

# Alternativa direta com Counter
from collections import Counter
counter = Counter(array)
```

### **2. Hash Map de Índice**

- Mapeia elemento → índice
- Ideal para: lookup, pares com soma, posição mais recente

```python
index_map = {}
for i, value in enumerate(array):
    index_map[value] = i
```

### **3. Hash Map de Estado**

- Mapeia estado → ocorrência
- Ideal para: prefixos/sufixos, estados em algoritmos

```python
# Exemplo de contagem de subarrays com soma específica
prefix_sum = 0
sum_map = {0: 1}  # Inicializa com 0 para contar desde o início
count = 0

for num in nums:
    prefix_sum += num
    if prefix_sum - k in sum_map:
        count += sum_map[prefix_sum - k]
    sum_map[prefix_sum] = sum_map.get(prefix_sum, 0) + 1
```

## **Combinações Fortes com Outras Técnicas**

### **Sliding Window + Hash Map**

```python
def longest_substring_k_distinct(s, k):
    char_count = {}
    left = 0
    max_len = 0
    
    for right in range(len(s)):
        # Add current character to window
        char_count[s[right]] = char_count.get(s[right], 0) + 1
        
        # Shrink window if we have more than k distinct chars
        while len(char_count) > k:
            char_count[s[left]] -= 1
            if char_count[s[left]] == 0:
                del char_count[s[left]]
            left += 1
            
        max_len = max(max_len, right - left + 1)
        
    return max_len
```

### **Prefix Sum + Hash Map**

```python
def subarray_sum_equals_k(nums, k):
    prefix_sum = 0
    result = 0
    sum_map = {0: 1}  # For empty subarray
    
    for num in nums:
        prefix_sum += num
        
        # Check if there was a previous sum that creates a subarray of sum k
        if prefix_sum - k in sum_map:
            result += sum_map[prefix_sum - k]
            
        # Update the frequency of current sum
        sum_map[prefix_sum] = sum_map.get(prefix_sum, 0) + 1
        
    return result
```

## **Problemas Clássicos no LeetCode**

| **Nome** | **ID** | **Tipo** | **Dificuldade** |
|----------|--------|----------|-----------------|
| Two Sum | #1 | Lookup direto | Easy |
| Valid Anagram | #242 | Hash de contagem | Easy |
| Group Anagrams | #49 | Hash de contagem | Medium |
| Subarray Sum Equals K | #560 | Prefix + hash | Medium |
| Longest Consecutive Sequence | #128 | Hash + DFS | Medium |
| Isomorphic Strings | #205 | Map de char-char | Easy |
| LRU Cache | #146 | HashMap + DLL | Medium |

## **Dicas Ninja**

- Use `collections.defaultdict(int)` ou `Counter` para simplificar.
- Em problemas com strings, **ordenar não é sempre eficiente**, usar hash de contagem pode ser melhor.
- Cuidado com dict mutável como valor — clone se for comparar snapshots.
- Guarde **índices ou posições** além de valores, para reconstruir respostas.
- Quando tiver problema com prefixos/somas parciais, pense em um hash map armazenando o estado.

## **Pensando Em Voz Alta: Longest Consecutive Sequence**

*Problema*: Dado um array não ordenado de inteiros, encontre o comprimento da sequência consecutiva mais longa.

*Exemplo*: Input: [100, 4, 200, 1, 3, 2] → Output: 4 (sequência [1, 2, 3, 4])

*Insights*:
1. Ordenar seria O(n log n), podemos fazer melhor com hash
2. Para cada número, verifique se o número é o início de uma sequência (n-1 não existe)
3. Se for início, comece a contar consecutivos usando hash

```python
def longest_consecutive(nums):
    if not nums:
        return 0
        
    num_set = set(nums)  # O(1) lookup
    max_length = 0
    
    for num in num_set:
        # Só verifica sequências a partir do início
        if num - 1 not in num_set:
            current_num = num
            current_streak = 1
            
            # Conta elementos consecutivos
            while current_num + 1 in num_set:
                current_num += 1
                current_streak += 1
                
            max_length = max(max_length, current_streak)
            
    return max_length
```

## **Checklist de Hash Maps**

- [ ] Sei implementar e usar mapas de contagem com defaultdict e Counter
- [ ] Entendi como usar prefixos com hash maps
- [ ] Consigo guardar estados complexos em hash maps
- [ ] Sei quando usar set vs. dict para otimização
- [ ] Implementei pelo menos 5 variações diferentes com mapas

## **Mini Desafio**

**Problema:** Verifique se duas strings são isomórficas (mesmo padrão de mapeamento 1-para-1 entre caracteres).

**Exemplo:**
- egg → add ✅ (e→a, g→d)
- foo → bar ❌ (f→b, o→a, o→r: o tenta mapear para dois caracteres)

**Solução**:
1. Use dois mapas: um para s→t e outro para t→s
2. Verifique se cada caractere tem um mapeamento único em ambas as direções
3. Garanta que o mapeamento é consistente

---

# **Prefix Sum & Difference Arrays: A Arte de Evitar Repetição**

## **Por Que Usar Prefix Sum?**

Quando você precisa calcular **somatórios em ranges repetidamente**, prefix sum é o seu melhor amigo.

Imagine: Quer saber a soma do intervalo arr[2:5] várias vezes. Em vez de somar manualmente, você usa prefixos:

sum[2:5] = prefix[5] - prefix[1]

Você transforma uma operação **O(n)** em **O(1)**.

## **Visualizando Prefix Sum**

```
Original: [3, 1, 4, 1, 5, 9, 2, 6]
Prefix:   [0, 3, 4, 8, 9, 14, 23, 25, 31]
          ↑   ↑
         [0] [1] = soma de 0 elementos = 0
             ↑   ↑
            [1] [2] = soma de arr[0] = 3
                 ↑   ↑ 
                [2] [3] = soma de arr[0:1] = 3+1 = 4
```

Para encontrar a soma de arr[2:5]: prefix[6] - prefix[2] = 23 - 4 = 19

## **Criando Prefix Sums**

```python
def build_prefix(nums):
    prefix = [0]  # Start with 0 for empty subarray
    
    for num in nums:
        prefix.append(prefix[-1] + num)
        
    return prefix
```

Agora prefix[i] representa a soma de nums[0] até nums[i-1].

## **Aplicações Comuns**

### **1. Subarray com Soma Específica**

**Problema:** Subarray Sum Equals K (#560)

Já vimos no Capítulo 4, mas reforçamos aqui pois é a essência de Prefix + Hash Map.

```python
def subarray_sum(nums, k):
    prefix = 0
    count = 0
    prefix_map = {0: 1}  # Empty subarray
    
    for num in nums:
        prefix += num
        count += prefix_map.get(prefix - k, 0)
        prefix_map[prefix] = prefix_map.get(prefix, 0) + 1
        
    return count
```

### **2. Range Sum Query**

```python
class NumArray:
    def __init__(self, nums):
        self.prefix = [0]
        for num in nums:
            self.prefix.append(self.prefix[-1] + num)
            
    def sumRange(self, left, right):
        return self.prefix[right + 1] - self.prefix[left]
```

### **3. Difference Array: Atualização de Intervalos**

Você quer adicionar +10 de arr[2] até arr[5] **sem iterar**? Use um array de diferença:

```python
def range_update(arr, updates):
    diff = [0] * (len(arr) + 1)
    
    for start, end, val in updates:
        diff[start] += val
        diff[end + 1] -= val
        
    # Reconstruímos o array original com as atualizações
    for i in range(1, len(arr)):
        diff[i] += diff[i - 1]
        
    return [arr[i] + diff[i] for i in range(len(arr))]
```

## **Prefix Sum em 2D Arrays**

Para matrizes 2D, prefix sum permite calcular a soma de qualquer sub-retângulo em O(1):

```python
def build_2d_prefix(matrix):
    if not matrix or not matrix[0]:
        return [[]]
        
    rows, cols = len(matrix), len(matrix[0])
    prefix = [[0] * (cols + 1) for _ in range(rows + 1)]
    
    for r in range(1, rows + 1):
        for c in range(1, cols + 1):
            prefix[r][c] = matrix[r-1][c-1] + prefix[r-1][c] + prefix[r][c-1] - prefix[r-1][c-1]
            
    return prefix

def get_sub_matrix_sum(prefix, r1, c1, r2, c2):
    return prefix[r2+1][c2+1] - prefix[r2+1][c1] - prefix[r1][c2+1] + prefix[r1][c1]
```

## **Aplicações Reais e Criativas**

- Histograma de frequências acumuladas
- Balanceamento de cargas em servidores (problemas simulados)
- Escalonamento de tarefas (intervalos com impacto)
- Análise de tendências em séries temporais

## **Problemas Clássicos no LeetCode**

| **Nome** | **ID** | **Técnica** | **Dificuldade** |
|----------|--------|-------------|-----------------|
| Range Sum Query - Immutable | #303 | Prefix Sum | Easy |
| Subarray Sum Equals K | #560 | Prefix + Hash | Medium |
| Maximum Size Subarray Sum Equals k | #325 | Prefix Sum | Medium |
| Corporate Flight Bookings | #1109 | Difference Array | Medium |
| Car Pooling | #1094 | Difference Array | Medium |
| Range Sum Query 2D - Immutable | #304 | 2D Prefix Sum | Medium |

## **Dicas de Proficiência**

- Guarde o prefixo da **posição zero** como 0 para evitar edge cases.
- Use dict para prefix sums se o array for muito grande e você quiser espaço otimizado.
- Em problems de atualização de ranges, Difference Array economiza tempo e espaço.
- Para matrizes 2D, lembre-se da fórmula: rect_sum = prefix[r2+1][c2+1] - prefix[r2+1][c1] - prefix[r1][c2+1] + prefix[r1][c1]

## **Pensando Em Voz Alta: Car Pooling**

*Problema*: Há uma van com capacidade capacity. Você recebe trips onde trips[i] = [num_passengers, start, end] representa uma viagem com num_passengers do ponto start até end. Determine se é possível completar todas as viagens.

*Insights*:
1. Posso usar difference array para rastrear adições e remoções de passageiros
2. Em cada ponto de início, adiciono passageiros; em cada ponto de fim, removo
3. Reconstruo o array de diferenças para verificar se excede a capacidade

```python
def car_pooling(trips, capacity):
    # Encontre o ponto mais distante
    last_location = 0
    for _, _, end in trips:
        last_location = max(last_location, end)
        
    # Crie o difference array
    diff = [0] * (last_location + 1)
    
    # Registre embarques e desembarques
    for num_passengers, start, end in trips:
        diff[start] += num_passengers  # Embarque
        diff[end] -= num_passengers    # Desembarque
        
    # Verifique se algum ponto excede a capacidade
    current = 0
    for passengers in diff:
        current += passengers
        if current > capacity:
            return False
            
    return True
```

## **Checklist Prefix/Diff**

- [ ] Sei calcular soma em ranges com prefix sum
- [ ] Sei fazer updates em ranges com difference array
- [ ] Entendi como aplicar prefix sum em matrizes 2D
- [ ] Combinei prefix com hash map para verificar padrões
- [ ] Implementei pelo menos 3 soluções utilizando estas técnicas

## **Mini Desafio**

**Problema:** Dado um array de atualizações em ranges, como:
updates = [[1, 3, 2], [2, 4, 3], [0, 2, -2]]

Retorne o array final após aplicar todas as atualizações sobre um array de tamanho 5, inicialmente com zeros.

**Solução**:
1. Crie um difference array de tamanho n+1
2. Para cada update [start, end, val], adicione val em diff[start] e subtraia val de diff[end+1]
3. Reconstrua o array original através do difference array somando cumulativamente

---

# **Binary Search: Cortando Pela Metade, Pensando com Precisão**

## **Por Que Binary Search é Uma Arma de Elite?**

Binary Search vai muito além de procurar elementos em arrays. É uma técnica para resolver **problemas com uma propriedade de monotonicidade**, onde podemos dividir o espaço de busca pela metade a cada iteração.

É isso que faz dela uma ferramenta lendária para transformar um problema O(n) em O(log n).

## **Visualizando Binary Search**

```
Array: [1, 2, 3, 4, 5, 6, 7, 8, 9]
        ↑           ↑           ↑
       left        mid         right

Procurando 7:
mid = 5 (valor 6)
6 < 7, então left = mid + 1

Array: [1, 2, 3, 4, 5, 6, 7, 8, 9]
                        ↑   ↑   ↑
                      left mid right

mid = 7 (valor 8)
8 > 7, então right = mid - 1

Array: [1, 2, 3, 4, 5, 6, 7, 8, 9]
                        ↑ ↑
                      left,right

mid = 6 (valor 7)
7 == 7, encontramos!
```

## **O Padrão Básico**

```python
def binary_search(arr, target):
    left, right = 0, len(arr) - 1
    
    while left <= right:
        mid = (left + right) // 2
        
        if arr[mid] == target:
            return mid
        elif arr[mid] < target:
            left = mid + 1
        else:
            right = mid - 1
            
    return -1  # Not found
```

Esse padrão pode ser adaptado para **encontrar limites, posições específicas, ou otimizar valores**.

## **Variações Importantes**

### **1. Busca de Limite Inferior (Lower Bound)**

```python
def lower_bound(arr, target):
    left, right = 0, len(arr)
    
    while left < right:
        mid = (left + right) // 2
        
        if arr[mid] < target:
            left = mid + 1
        else:
            right = mid
            
    return left
```

Encontra o primeiro elemento >= target.

### **2. Busca de Limite Superior (Upper Bound)**

```python
def upper_bound(arr, target):
    left, right = 0, len(arr)
    
    while left < right:
        mid = (left + right) // 2
        
        if arr[mid] <= target:
            left = mid + 1
        else:
            right = mid
            
    return left
```

Encontra o primeiro elemento > target.

### **3. Binary Search no Espaço de Resposta**

```python
def min_capacity(weights, D):
    def can_ship(capacity):
        days = 1
        total = 0
        
        for w in weights:
            if total + w > capacity:
                days += 1
                total = 0
            total += w
            
        return days <= D
    
    left = max(weights)   # Mínima capacidade possível
    right = sum(weights)  # Máxima capacidade possível
    
    while left < right:
        mid = (left + right) // 2
        
        if can_ship(mid):
            right = mid
        else:
            left = mid + 1
            
    return left
```

## **Onde Aplicar Binary Search**

| **Tipo de problema** | **Aplicação de Binary Search** |
|----------------------|--------------------------------|
| Procurar valor | Em arrays ordenados |
| Procurar primeira/última ocorrência | Binary Search com ajustes |
| Otimizar um número | Binary Search no espaço de resposta |
| Verificar se possível | Usar uma função isValid(mid) para guiar |

## **Casos Práticos**

### **1. Search Insert Position**

**LeetCode #35**

```python
def searchInsert(nums, target):
    left, right = 0, len(nums) - 1
    
    while left <= right:
        mid = (left + right) // 2
        
        if nums[mid] < target:
            left = mid + 1
        else:
            right = mid - 1
            
    return left
```

➡️ Quando não encontra, retorna onde o valor deveria estar.

### **2. Find First and Last Position of Element**

**LeetCode #34**

```python
def searchRange(nums, target):
    def find_first():
        left, right = 0, len(nums) - 1
        result = -1
        
        while left <= right:
            mid = (left + right) // 2
            
            if nums[mid] == target:
                result = mid
                right = mid - 1  # Continue buscando à esquerda
            elif nums[mid] < target:
                left = mid + 1
            else:
                right = mid - 1
                
        return result
        
    def find_last():
        left, right = 0, len(nums) - 1
        result = -1
        
        while left <= right:
            mid = (left + right) // 2
            
            if nums[mid] == target:
                result = mid
                left = mid + 1  # Continue buscando à direita
            elif nums[mid] < target:
                left = mid + 1
            else:
                right = mid - 1
                
        return result
        
    return [find_first(), find_last()]
```

### **3. Find Minimum in Rotated Sorted Array**

**LeetCode #153**

```python
def findMin(nums):
    left, right = 0, len(nums) - 1
    
    while left < right:
        mid = (left + right) // 2
        
        if nums[mid] > nums[right]:
            left = mid + 1
        else:
            right = mid
            
    return nums[left]
```

## **Conceitos Cruciais na Binary Search**

### **1. Overflow na Obtenção do Mid**

Em linguagens como C/C++, usar:
```cpp
int mid = (left + right) / 2;  // Pode dar overflow
```

Melhor abordagem:
```cpp
int mid = left + (right - left) / 2;  // Previne overflow
```

### **2. Descida Para o Elemento Correto**

Dependendo do problema:
- Se `left <= right`: busca termina quando os ponteiros se cruzam
- Se `left < right`: busca termina quando os ponteiros se encontram

### **3. Monotonicidade**

A propriedade fundamental: o espaço de busca deve ser dividido em duas regiões distintas onde a condição muda exatamente uma vez.

```
[F, F, F, T, T, T, T]
          ↑
     Ponto de mudança
```

## **Dicas Ninja**

- Binary Search é sobre **valores, não apenas índices**
- Pode funcionar em **arrays virtuais** ou infinitos
- **Não confie apenas no template**: entenda a monotonicidade!
- Para otimizações, crie uma função isValid() e busque o menor/maior valor que a satisfaz
- Desenhe o caso para visualizar o comportamento dos ponteiros

## **Problemas Clássicos para Masterizar**

| **Problema** | **LeetCode ID** | **Dificuldade** |
|--------------|-----------------|-----------------|
| Binary Search | #704 | Easy |
| Search Insert Position | #35 | Easy |
| First Bad Version | #278 | Easy |
| Find First and Last Position | #34 | Medium |
| Koko Eating Bananas | #875 | Medium |
| Find Minimum in Rotated Sorted Array | #153 | Medium |
| Search in Rotated Sorted Array | #33 | Medium |
| Median of Two Sorted Arrays | #4 | Hard |

## **Pensando Em Voz Alta: Koko Eating Bananas**

*Problema*: Koko adora comer bananas. Há N pilhas de bananas, a i-ésima pilha tem piles[i] bananas. O guarda vai embora em H horas. Koko pode comer bananas à velocidade de K por hora. Dado que ela só pode comer de uma pilha por hora, encontre o menor K para que ela consuma todas as bananas antes do guarda voltar.

*Insights*:
1. O limite mínimo de K é 1
2. O limite máximo de K é o máximo dos piles (comer a maior pilha em 1 hora)
3. Para cada valor de K, posso calcular quantas horas Koko leva
4. Busco o menor K que satisfaz a condição

```python
def minEatingSpeed(piles, h):
    def hours_to_eat(k):
        return sum((pile + k - 1) // k for pile in piles)  # Ceiling division
        
    left, right = 1, max(piles)
    
    while left < right:
        mid = (left + right) // 2
        
        if hours_to_eat(mid) <= h:
            right = mid  # Tenta reduzir a velocidade
        else:
            left = mid + 1  # Precisa aumentar a velocidade
            
    return left
```

## **Checklist Binary Search**

- [ ] Consigo implementar busca binária clássica sem erros
- [ ] Entendi as variações de lower/upper bound
- [ ] Sei aplicar binary search em espaço de resposta
- [ ] Implementei soluções para arrays rotacionados
- [ ] Pratiquei pelo menos 5 problemas de binary search

## **Mini Desafio**

**Problema:** Dado um array ordenado e um target, encontre a primeira posição onde ele aparece (ou -1 se não existir).

**Solução**:
1. Use binary search padrão com uma variável para armazenar a posição encontrada
2. Continue buscando à esquerda mesmo após encontrar o target
3. Retorne a posição mais à esquerda encontrada

---

# **Depth-First Search & Backtracking: Explorando Todas as Possibilidades**

## **O Poder da Exploração Recursiva**

Depth-First Search (DFS) e Backtracking são técnicas que nos permitem **explorar sistematicamente todas as possibilidades** em um espaço de busca. São fundamentais para:

- Explorar árvores e grafos
- Encontrar todos os caminhos possíveis
- Resolver problemas de permutação e combinação
- Quebrar problemas complexos em subproblemas

A diferença entre ambos é sutil:
- **DFS** é a técnica de busca em profundidade
- **Backtracking** é DFS com a capacidade de "desfazer" escolhas e tentar novos caminhos

## **Visualizando DFS e Backtracking**

```
                  Root
                /  |  \
               A   B   C
              / \     / \
             D   E   F   G
```

Exploração DFS: Root → A → D → E → B → C → F → G

Backtracking em Permutação de [1,2,3]:
```
                []
              /  |  \
            [1]  [2]  [3]
           /  \    ...  ...
       [1,2] [1,3]
       /       \
  [1,2,3]     [1,3,2]
```

## **Implementação Base de DFS**

### **1. DFS Recursivo em Árvore**

```python
def dfs(node):
    if not node:
        return
        
    # Processar o nó atual
    process(node)
    
    # Explorar à esquerda e direita
    dfs(node.left)
    dfs(node.right)
```

### **2. DFS Recursivo em Grafo**

```python
def dfs(graph, node, visited):
    if node in visited:
        return
        
    visited.add(node)
    
    # Processar o nó atual
    process(node)
    
    # Explorar vizinhos
    for neighbor in graph[node]:
        dfs(graph, neighbor, visited)
```

### **3. DFS Iterativo com Stack**

```python
def dfs_iterative(graph, start):
    visited = set()
    stack = [start]
    
    while stack:
        node = stack.pop()
        
        if node in visited:
            continue
            
        visited.add(node)
        process(node)
        
        # Adicione vizinhos à pilha
        for neighbor in graph[node]:
            if neighbor not in visited:
                stack.append(neighbor)
```

## **Padrão de Backtracking**

```python
def backtrack(current_state, choices, result):
    # Condição de base: estado final alcançado
    if is_solution(current_state):
        result.append(current_state.copy())  # Adiciona cópia da solução
        return
        
    # Tenta cada escolha possível
    for choice in choices:
        if is_valid(current_state, choice):
            # Aplica a escolha
            make_choice(current_state, choice)
            
            # Explora com a escolha feita
            backtrack(current_state, choices, result)
            
            # Desfaz a escolha (backtrack)
            undo_choice(current_state, choice)
```

## **Problemas Clássicos de DFS**

### **1. Percorrendo uma Árvore Binária**

```python
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

def inorder_traversal(root):
    result = []
    
    def dfs(node):
        if not node:
            return
            
        dfs(node.left)  # Esquerda
        result.append(node.val)  # Raiz
        dfs(node.right)  # Direita
        
    dfs(root)
    return result
```

### **2. Number of Islands (LeetCode #200)**

```python
def numIslands(grid):
    if not grid or not grid[0]:
        return 0
        
    rows, cols = len(grid), len(grid[0])
    islands = 0
    
    def dfs(r, c):
        # Fora dos limites ou não é terra
        if r < 0 or r >= rows or c < 0 or c >= cols or grid[r][c] != '1':
            return
            
        # Marca como visitado
        grid[r][c] = '0'
        
        # Explora as 4 direções
        dfs(r+1, c)
        dfs(r-1, c)
        dfs(r, c+1)
        dfs(r, c-1)
    
    for r in range(rows):
        for c in range(cols):
            if grid[r][c] == '1':
                islands += 1
                dfs(r, c)  # Marca toda a ilha como visitada
                
    return islands
```

## **Problemas Clássicos de Backtracking**

### **1. Permutações (LeetCode #46)**

```python
def permute(nums):
    result = []
    
    def backtrack(current, remaining):
        if not remaining:
            result.append(current[:])
            return
            
        for i in range(len(remaining)):
            # Escolha
            current.append(remaining[i])
            
            # Explora
            backtrack(current, remaining[:i] + remaining[i+1:])
            
            # Desfaz (backtrack)
            current.pop()
    
    backtrack([], nums)
    return result
```

### **2. Subsets (LeetCode #78)**

```python
def subsets(nums):
    result = []
    
    def backtrack(start, current):
        # Cada estado intermediário é uma solução válida
        result.append(current[:])
        
        for i in range(start, len(nums)):
            # Inclui o elemento
            current.append(nums[i])
            
            # Explora com esse elemento adicionado
            backtrack(i + 1, current)
            
            # Remove o elemento
            current.pop()
    
    backtrack(0, [])
    return result
```

## **Otimizações em Backtracking**

### **1. Poda (Pruning)**

Elimine caminhos que você sabe que não levarão a soluções válidas.

```python
def combinationSum(candidates, target):
    result = []
    candidates.sort()  # Ajuda na poda
    
    def backtrack(start, current, remaining):
        if remaining == 0:
            result.append(current[:])
            return
            
        for i in range(start, len(candidates)):
            # Poda: se o candidato atual é maior que o restante, nenhum posterior será válido
            if candidates[i] > remaining:
                break
                
            # Evita processamento duplicado
            if i > start and candidates[i] == candidates[i-1]:
                continue
                
            current.append(candidates[i])
            backtrack(i, current, remaining - candidates[i])  # Pode reutilizar o mesmo elemento
            current.pop()
    
    backtrack(0, [], target)
    return result
```

### **2. Memorização**

Guarde resultados de subproblemas já calculados.

```python
def word_break(s, wordDict):
    words = set(wordDict)
    memo = {}
    
    def can_break(start):
        if start == len(s):
            return True
            
        if start in memo:
            return memo[start]
            
        for end in range(start + 1, len(s) + 1):
            if s[start:end] in words and can_break(end):
                memo[start] = True
                return True
                
        memo[start] = False
        return False
        
    return can_break(0)
```

## **Problemas Populares no LeetCode**

| **Nome** | **ID** | **Técnica** | **Dificuldade** |
|----------|--------|-------------|-----------------|
| Number of Islands | #200 | DFS | Medium |
| Max Area of Island | #695 | DFS | Medium |
| Permutations | #46 | Backtracking | Medium |
| Subsets | #78 | Backtracking | Medium |
| Combination Sum | #39 | Backtracking | Medium |
| N-Queens | #51 | Backtracking | Hard |
| Word Search | #79 | DFS | Medium |
| Sudoku Solver | #37 | Backtracking | Hard |

## **Dicas Ninja**

- Sempre marque nós como visitados para evitar ciclos.
- Em problemas de matriz, uma maneira comum de marcar como visitado é modificar o próprio valor.
- Tente usar **poda** para eliminar caminhos inviáveis o mais cedo possível.
- Para subsets/combinações, a ordenação prévia geralmente ajuda.
- Verifique se o problema requer todas as soluções ou apenas uma solução.
- Use memoization para DFS em problemas que revisitam os mesmos estados.

## **Pensando Em Voz Alta: Word Search**

*Problema*: Dada uma matriz de caracteres e uma palavra, verifique se a palavra existe na matriz. A palavra pode ser construída a partir de letras adjacentes na matriz, onde adjacente significa horizontalmente ou verticalmente vizinho. A mesma célula não pode ser usada mais de uma vez.

*Insights*:
1. Para cada célula na matriz, tente iniciar um DFS se o caractere coincidir com o primeiro da palavra
2. A cada passo do DFS, verifique as 4 direções
3. Marque as células visitadas para evitar reuso
4. Desmarque ao fazer backtrack

```python
def exist(board, word):
    rows, cols = len(board), len(board[0])
    
    def dfs(r, c, index):
        # Encontramos a palavra completa
        if index == len(word):
            return True
            
        # Fora dos limites ou caractere não coincide
        if (r < 0 or r >= rows or c < 0 or c >= cols or 
            board[r][c] != word[index]):
            return False
            
        # Marca como visitada temporariamente
        temp = board[r][c]
        board[r][c] = '#'
        
        # Explora as 4 direções
        found = (dfs(r+1, c, index+1) or 
                 dfs(r-1, c, index+1) or 
                 dfs(r, c+1, index+1) or 
                 dfs(r, c-1, index+1))
        
        # Backtrack - restaura o caractere
        board[r][c] = temp
        
        return found
    
    # Tenta iniciar DFS de cada célula
    for r in range(rows):
        for c in range(cols):
            if board[r][c] == word[0] and dfs(r, c, 0):
                return True
                
    return False
```

## **Checklist DFS/Backtracking**

- [ ] Entendo a diferença entre DFS iterativo e recursivo
- [ ] Sei aplicar DFS em árvores e grafos
- [ ] Compreendo o padrão de backtracking (escolha, exploração, desfazer)
- [ ] Sei otimizar backtracking com poda
- [ ] Implementei pelo menos 5 problemas usando estas técnicas

## **Mini Desafio**

**Problema:** Gere todas as combinações possíveis de k números escolhidos de 1 a n.

**Exemplo:** 
Input: n = 4, k = 2
Output: [[1,2], [1,3], [1,4], [2,3], [2,4], [3,4]]

**Solução**:
1. Use backtracking para gerar as combinações
2. Para cada número de 1 a n, decida incluí-lo ou não na combinação atual
3. Quando a combinação tiver tamanho k, adicione-a ao resultado

---

# **Breadth-First Search & Graph Traversal: Caminho Mais Curto e Além**

## **Quando a Largura Supera a Profundidade**

Breadth-First Search (BFS) é uma técnica de travessia que explora todos os vizinhos de um nó antes de se mover para o próximo nível. É essencial para:

- Encontrar o **caminho mais curto** em grafos não ponderados
- Atravessar uma árvore por níveis
- Resolver labirintos e problemas de conectividade
- Detectar componentes em grafos não direcionados

A principal diferença para DFS:
- DFS vai o mais longe possível em um caminho antes de retroceder
- BFS explora em "ondas" ou níveis, garantindo caminhos mínimos

## **Visualizando BFS**

```
             A
           / | \
          B  C  D
         / \    |
        E   F   G
```

Travessia BFS: A → B → C → D → E → F → G (Nível por nível)

## **Implementação Clássica de BFS**

```python
from collections import deque

def bfs(graph, start):
    visited = set([start])
    queue = deque([start])
    
    while queue:
        node = queue.popleft()  # Remove o primeiro (FIFO)
        process(node)
        
        for neighbor in graph[node]:
            if neighbor not in visited:
                visited.add(neighbor)
                queue.append(neighbor)
```

## **BFS para Encontrar Caminho Mais Curto**

```python
def shortest_path(graph, start, end):
    if start == end:
        return [start]
        
    visited = set([start])
    queue = deque([(start, [start])])  # (node, path_so_far)
    
    while queue:
        node, path = queue.popleft()
        
        for neighbor in graph[node]:
            if neighbor == end:
                return path + [neighbor]  # Caminho encontrado!
                
            if neighbor not in visited:
                visited.add(neighbor)
                queue.append((neighbor, path + [neighbor]))
                
    return None  # Sem caminho
```

## **BFS Multi-Source (Múltiplas Origens)**

```python
def multi_source_bfs(grid, sources):
    rows, cols = len(grid), len(grid[0])
    queue = deque(sources)  # Começa com múltiplas origens
    visited = set(sources)
    
    level = 0
    while queue:
        size = len(queue)
        
        for _ in range(size):
            r, c = queue.popleft()
            
            # Processar nó atual
            process(r, c, level)
            
            # Direções: cima, direita, baixo, esquerda
            for dr, dc in [(0, 1), (1, 0), (0, -1), (-1, 0)]:
                nr, nc = r + dr, c + dc
                
                if (0 <= nr < rows and 0 <= nc < cols and 
                    grid[nr][nc] == 0 and (nr, nc) not in visited):
                    visited.add((nr, nc))
                    queue.append((nr, nc))
                    
        level += 1  # Próximo nível
```

## **Problemas Clássicos de BFS**

### **1. Binary Tree Level Order Traversal**

```python
def levelOrder(root):
    if not root:
        return []
        
    result = []
    queue = deque([root])
    
    while queue:
        level_size = len(queue)
        level = []
        
        for _ in range(level_size):
            node = queue.popleft()
            level.append(node.val)
            
            if node.left:
                queue.append(node.left)
                
            if node.right:
                queue.append(node.right)
                
        result.append(level)
        
    return result
```

### **2. Rotten Oranges (LeetCode #994)**

```python
def orangesRotting(grid):
    rows, cols = len(grid), len(grid[0])
    queue = deque()
    fresh_count = 0
    
    # Encontrar todas as laranjas podres e contar as frescas
    for r in range(rows):
        for c in range(cols):
            if grid[r][c] == 2:  # Podre
                queue.append((r, c))
            elif grid[r][c] == 1:  # Fresca
                fresh_count += 1
    
    # Sem laranjas frescas, já terminamos
    if fresh_count == 0:
        return 0
        
    # BFS a partir de todas as laranjas podres
    minutes = 0
    while queue and fresh_count > 0:
        size = len(queue)
        
        for _ in range(size):
            r, c = queue.popleft()
            
            for dr, dc in [(0, 1), (1, 0), (0, -1), (-1, 0)]:
                nr, nc = r + dr, c + dc
                
                if (0 <= nr < rows and 0 <= nc < cols and grid[nr][nc] == 1):
                    grid[nr][nc] = 2  # Contamina
                    fresh_count -= 1
                    queue.append((nr, nc))
                    
        minutes += 1
        
    return minutes if fresh_count == 0 else -1
```

## **BFS em Grafos Implícitos**

Muitos problemas envolvem grafos que não são explicitamente fornecidos, mas estão implícitos na descrição do problema:

```python
def word_ladder(beginWord, endWord, wordList):
    word_set = set(wordList)
    if endWord not in word_set:
        return 0
        
    queue = deque([(beginWord, 1)])  # (word, length_so_far)
    visited = set([beginWord])
    
    while queue:
        current_word, length = queue.popleft()
        
        if current_word == endWord:
            return length
            
        # Gere todas as transformações de uma letra
        for i in range(len(current_word)):
            for c in 'abcdefghijklmnopqrstuvwxyz':
                next_word = current_word[:i] + c + current_word[i+1:]
                
                if next_word in word_set and next_word not in visited:
                    visited.add(next_word)
                    queue.append((next_word, length + 1))
                    
    return 0
```

## **Bi-directional BFS**

Para melhorar a eficiência em alguns problemas, podemos realizar BFS a partir do início e do fim simultaneamente:

```python
def bidirectional_bfs(graph, start, end):
    if start == end:
        return 1
        
    forward_queue = deque([start])
    backward_queue = deque([end])
    
    forward_visited = {start: 1}  # node -> distance
    backward_visited = {end: 1}
    
    while forward_queue and backward_queue:
        # Expande a frente menor para otimizar
        if len(forward_queue) <= len(backward_queue):
            distance = expand_front(graph, forward_queue, forward_visited, backward_visited)
        else:
            distance = expand_front(graph, backward_queue, backward_visited, forward_visited)
            
        if distance:
            return distance
            
    return -1  # Sem caminho

def expand_front(graph, queue, visited, other_visited):
    node = queue.popleft()
    distance = visited[node]
    
    for neighbor in graph[node]:
        if neighbor in other_visited:  # Encontrou interseção
            return distance + other_visited[neighbor] - 1
            
        if neighbor not in visited:
            visited[neighbor] = distance + 1
            queue.append(neighbor)
            
    return None
```

## **Problemas Populares no LeetCode**

| **Nome** | **ID** | **Técnica** | **Dificuldade** |
|----------|--------|-------------|-----------------|
| Binary Tree Level Order Traversal | #102 | BFS Simples | Medium |
| Rotting Oranges | #994 | Multi-source BFS | Medium |
| Word Ladder | #127 | BFS em Grafo Implícito | Hard |
| Shortest Bridge | #934 | Multi-source BFS | Medium |
| Course Schedule | #207 | BFS/Topological Sort | Medium |
| Walls and Gates | #286 | Multi-source BFS | Medium |
| 01 Matrix | #542 | Multi-source BFS | Medium |

## **Dicas Ninja para Grafos**

- Use `collections.deque` para implementações eficientes de BFS (O(1) para popleft).
- Para grafos implícitos, defina claramente quais são os "nós" e "arestas".
- Em problemas de matriz, use um array de direções para simplificar código.
- Para detectar ciclos em grafos direcionados, combine BFS com contagem de grau de entrada.
- Mantenha um mapa de distâncias em vez de apenas um conjunto de visitados para rastrear níveis.
- Considere BFS bidirecional para melhorar a eficiência em grafos grandes.

## **Pensando Em Voz Alta: 01 Matrix**

*Problema*: Dada uma matriz com 0s e 1s, calcule a distância do 0 mais próximo para cada célula. A distância é o número mínimo de passos para chegar a um 0.

*Insights*:
1. BFS multi-source começando de todos os zeros simultaneamente
2. À medida que a BFS progride, a distância é o nível na BFS
3. Isso garante que cada célula 1 obtenha a menor distância a um 0

```python
def update_matrix(mat):
    rows, cols = len(mat), len(mat[0])
    queue = deque()
    
    # Inicia com todos os 0s como fontes
    for r in range(rows):
        for c in range(cols):
            if mat[r][c] == 0:
                queue.append((r, c))
            else:
                mat[r][c] = float('inf')  # Marca 1s como infinito
    
    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]
    
    # BFS multi-source
    while queue:
        r, c = queue.popleft()
        
        for dr, dc in directions:
            nr, nc = r + dr, c + dc
            
            # Se a célula adjacente pode ser melhorada
            if (0 <= nr < rows and 0 <= nc < cols and 
                mat[nr][nc] > mat[r][c] + 1):
                mat[nr][nc] = mat[r][c] + 1
                queue.append((nr, nc))
                
    return mat
```

## **Checklist BFS & Grafos**

- [ ] Entendo a implementação básica de BFS com queue
- [ ] Sei encontrar caminhos mais curtos com BFS
- [ ] Implementei BFS multi-source em problemas de matriz
- [ ] Sei como aplicar BFS em grafos implícitos
- [ ] Conheço técnicas para otimizar BFS em grafos grandes

## **Mini Desafio**

**Problema:** Em uma matriz binária com 1s (terra) e 0s (água), encontre a ilha mais distante da costa (em termos de distância).

**Exemplo:** 
```
[0, 0, 0, 0]
[0, 1, 1, 0]
[0, 1, 1, 0]
[0, 0, 0, 0]
```
A ilha mais distante da costa está a 1 unidade de distância.

**Solução**:
1. Use multi-source BFS começando de todas as células de água (0s)
2. À medida que o BFS avança, as distâncias são calculadas
3. A maior distância encontrada é a resposta

---

# **Dynamic Programming: Construindo Soluções Incrementais**

## **A Arte de Armazenar Subproblemas**

Dynamic Programming (DP) é uma técnica poderosa para otimizar problemas que têm:
- Subestrutura ótima (a solução ótima contém soluções ótimas de subproblemas)
- Sobreposição de subproblemas (os mesmos subproblemas são resolvidos múltiplas vezes)

DP transforma problemas exponenciais em polinomiais ao **armazenar e reutilizar resultados de subproblemas**.

## **Os Dois Principais Abordagens**

### **1. Memoization (Top-down)**

```python
def fibonacci(n, memo={}):
    if n in memo:
        return memo[n]
        
    if n <= 1:
        return n
        
    memo[n] = fibonacci(n-1, memo) + fibonacci(n-2, memo)
    return memo[n]
```

### **2. Tabulation (Bottom-up)**

```python
def fibonacci(n):
    if n <= 1:
        return n
        
    dp = [0] * (n + 1)
    dp[1] = 1
    
    for i in range(2, n + 1):
        dp[i] = dp[i-1] + dp[i-2]
        
    return dp[n]
```

## **Framework para Resolver Problemas de DP**

1. **Definir o estado**: O que os índices da matriz dp significam?
2. **Definir a base**: Quais são os casos mais simples?
3. **Formular a recorrência**: Como resolver para dp[i] usando valores anteriores?
4. **Ordenação de computação**: Em que ordem computar os valores?
5. **Encontrar a resposta**: Qual valor na matriz dp é a solução final?

## **Padrões de DP e Exemplos**

### **1. Sequências Lineares**

**Problema**: Subsequência Crescente Mais Longa (LeetCode #300)

```python
def lengthOfLIS(nums):
    if not nums:
        return 0
        
    n = len(nums)
    dp = [1] * n  # Cada elemento é uma subsequência de tamanho 1
    
    for i in range(n):
        for j in range(i):
            if nums[i] > nums[j]:  # Se podemos adicionar nums[i] após nums[j]
                dp[i] = max(dp[i], dp[j] + 1)
                
    return max(dp)
```

### **2. DP em Strings**

**Problema**: Subsequência Comum Mais Longa (LCS)

```python
def longestCommonSubsequence(text1, text2):
    m, n = len(text1), len(text2)
    dp = [[0] * (n + 1) for _ in range(m + 1)]
    
    for i in range(1, m + 1):
        for j in range(1, n + 1):
            if text1[i-1] == text2[j-1]:
                dp[i][j] = dp[i-1][j-1] + 1
            else:
                dp[i][j] = max(dp[i-1][j], dp[i][j-1])
                
    return dp[m][n]
```

### **3. DP em Grade/Matriz**

**Problema**: Unique Paths (LeetCode #62)

```python
def uniquePaths(m, n):
    dp = [[1] * n for _ in range(m)]
    
    for i in range(1, m):
        for j in range(1, n):
            dp[i][j] = dp[i-1][j] + dp[i][j-1]
            
    return dp[m-1][n-1]
```

### **4. Problema da Mochila (Knapsack)**

**Problema**: 0/1 Knapsack

```python
def knapsack(weights, values, capacity):
    n = len(weights)
    dp = [[0] * (capacity + 1) for _ in range(n + 1)]
    
    for i in range(1, n + 1):
        for w in range(capacity + 1):
            if weights[i-1] <= w:
                dp[i][w] = max(values[i-1] + dp[i-1][w-weights[i-1]], dp[i-1][w])
            else:
                dp[i][w] = dp[i-1][w]
                
    return dp[n][capacity]
```

### **5. DP com Otimização de Estado**

**Problema**: House Robber (LeetCode #198)

```python
def rob(nums):
    if not nums:
        return 0
        
    if len(nums) == 1:
        return nums[0]
        
    # dp[i] = máximo que pode ser roubado até a casa i
    dp = [0] * len(nums)
    dp[0] = nums[0]
    dp[1] = max(nums[0], nums[1])
    
    for i in range(2, len(nums)):
        dp[i] = max(dp[i-1], dp[i-2] + nums[i])
        
    return dp[-1]
```

## **Otimizando Espaço em DP**

Muitos problemas de DP podem ser otimizados para usar apenas O(1) ou O(n) espaço:

```python
def rob_optimized(nums):
    if not nums:
        return 0
        
    if len(nums) == 1:
        return nums[0]
        
    # Só precisamos de dois estados anteriores
    prev1 = max(nums[0], nums[1])  # dp[1]
    prev2 = nums[0]  # dp[0]
    
    for i in range(2, len(nums)):
        current = max(prev1, prev2 + nums[i])
        prev2, prev1 = prev1, current
        
    return prev1
```

## **Problemas Populares no LeetCode**

| **Nome** | **ID** | **Padrão** | **Dificuldade** |
|----------|--------|------------|-----------------|
| Climbing Stairs | #70 | Sequência Linear | Easy |
| House Robber | #198 | Sequência Linear | Medium |
| Longest Increasing Subsequence | #300 | Sequência Linear | Medium |
| Coin Change | #322 | Knapsack | Medium |
| Longest Common Subsequence | #1143 | DP em Strings | Medium |
| Regular Expression Matching | #10 | DP em Strings | Hard |
| Edit Distance | #72 | DP em Strings | Hard |
| Maximum Subarray | #53 | Kadane | Easy |

## **Dicas Ninja para DP**

- Sempre comece com a abordagem recursiva (top-down) para entender a relação de recorrência.
- Desenhe uma árvore de recursão para identificar subproblemas sobrepostos.
- Para otimização de espaço, verifique se você só precisa dos últimos estados.
- Quando trabalhar com arrays, considere ordenar primeiro se isso simplificar o problema.
- Em problemas de subsequência, tente formular a recorrência baseada em incluir ou não incluir o elemento atual.
- Tenha cuidado com a inicialização de valores base - geralmente é o caso mais simples do problema.
- Para problemas de DP em duas dimensões, desenhe a tabela e trace alguns exemplos manualmente.

## **Pensando Em Voz Alta: Coin Change**

*Problema*: Dada uma lista de moedas de diferentes valores e um valor total, encontre o número mínimo de moedas necessárias para fazer esse valor. Se não for possível, retorne -1.

*Insights*:
1. Estado: dp[i] = número mínimo de moedas para fazer i
2. Base: dp[0] = 0 (não preciso de moedas para fazer 0)
3. Transição: dp[i] = min(dp[i], dp[i-coin] + 1) para cada moeda
4. Ordem: calcular de 1 até amount
5. Resposta: dp[amount]

```python
def coinChange(coins, amount):
    # Inicializa com valor impossível
    dp = [float('inf')] * (amount + 1)
    dp[0] = 0  # Base: 0 moedas para fazer 0
    
    for coin in coins:
        for i in range(coin, amount + 1):
            dp[i] = min(dp[i], dp[i - coin] + 1)
            
    return dp[amount] if dp[amount] != float('inf') else -1
```

Isso é mais eficiente que a forma intuitiva de iterar por amount e depois por coins, porque evitamos recomputações desnecessárias.

## **Checklist Dynamic Programming**

- [ ] Entendo a diferença entre abordagens top-down e bottom-up
- [ ] Consigo identificar subproblemas sobrepostos
- [ ] Sei formular relações de recorrência
- [ ] Consigo otimizar espaço em soluções de DP
- [ ] Implementei pelo menos 5 soluções de DP diferentes

## **Mini Desafio**

**Problema:** Dada uma matriz m x n preenchida com números não negativos, encontre um caminho do topo esquerdo para o canto inferior direito, que minimize a soma dos números por onde você passa.

**Nota**: Você só pode se mover para baixo ou para a direita.

**Solução**:
1. Crie uma matriz dp onde dp[i][j] é a soma mínima para chegar à posição (i,j)
2. Use a recorrência: dp[i][j] = grid[i][j] + min(dp[i-1][j], dp[i][j-1])
3. Inicialize as bordas apropriadamente
4. A resposta será dp[m-1][n-1]

---

# **Greedy Algorithms: Otimizando Passo a Passo**

## **A Intuição por Trás dos Algoritmos Gulosos**

Algoritmos Gulosos (Greedy) fazem escolhas localmente ótimas a cada passo, com a esperança de encontrar um ótimo global. Eles são eficientes quando:

- A escolha gulosa local leva à solução ótima global
- Não há necessidade de olhar para trás ou reconsiderar escolhas anteriores
- O problema tem "subestrutura ótima" (como DP) mas sem sobreposição

A grande vantagem: são geralmente mais simples e eficientes que DP ou Backtracking.

## **Como Reconhecer Problemas Greedy**

Problemas Greedy geralmente envolvem:
- Maximizar ou minimizar algo
- Fazer escolhas incrementais sem reconsiderar
- Ordenação que estabelece uma prioridade clara
- Problemas de intervalo, agendamento ou seleção

## **Prova de Algoritmos Greedy**

Diferente de outras técnicas, algoritmos gulosos geralmente requerem **provas matemáticas** para garantir que funcionam:

1. **Prova por Indução**: Mostrar que se as primeiras k escolhas são ótimas, então a k+1-ésima também é
2. **Prova por Contradição**: Assumir que existe uma solução melhor e derivar uma contradição
3. **Prova por Troca**: Mostrar que qualquer solução não-gulosa pode ser transformada em uma solução gulosa sem piorar

## **Exemplos Clássicos**

### **1. Activity Selection (Seleção de Atividades)**

**Problema**: Dado um conjunto de atividades com horários de início e fim, selecione o número máximo de atividades que não se sobrepõem.

```python
def activity_selection(start, finish):
    # Ordenar atividades por tempo de término
    activities = sorted(zip(start, finish), key=lambda x: x[1])
    selected = [activities[0]]  # Seleciona a primeira atividade
    
    for activity in activities[1:]:
        # Se a atividade atual não sobrepõe a última selecionada
        if activity[0] >= selected[-1][1]:
            selected.append(activity)
            
    return selected
```

### **2. Fractional Knapsack (Mochila Fracionária)**

**Problema**: Dada uma mochila com capacidade W e itens com valores e pesos, maximize o valor total na mochila. Você pode pegar frações de itens.

```python
def fractional_knapsack(values, weights, capacity):
    # Calcular razão valor/peso
    ratio = [(v/w, v, w) for v, w in zip(values, weights)]
    ratio.sort(reverse=True)  # Ordenar por razão valor/peso
    
    total_value = 0
    
    for r, v, w in ratio:
        if capacity >= w:  # Pegar o item inteiro
            total_value += v
            capacity -= w
        else:  # Pegar fração do item
            total_value += v * (capacity / w)
            break
            
    return total_value
```

### **3. Huffman Coding (Codificação de Huffman)**

**Problema**: Criar um código de prefixo ótimo para compressão de dados.

```python
import heapq
from collections import Counter

def huffman_encoding(text):
    # Contagem de frequência
    freq = Counter(text)
    
    # Criar heap mínima dos nós
    heap = [[weight, [char, ""]] for char, weight in freq.items()]
    heapq.heapify(heap)
    
    # Construir a árvore de Huffman
    while len(heap) > 1:
        lo = heapq.heappop(heap)
        hi = heapq.heappop(heap)
        
        for pair in lo[1:]:
            pair[1] = '0' + pair[1]
        for pair in hi[1:]:
            pair[1] = '1' + pair[1]
            
        heapq.heappush(heap, [lo[0] + hi[0]] + lo[1:] + hi[1:])
        
    # Extrair códigos
    huffman_codes = {char: code for char, code in heap[0][1:]}
    return huffman_codes
```

## **Aplicações em Problemas do LeetCode**

### **1. Jump Game (LeetCode #55)**

```python
def canJump(nums):
    max_reach = 0
    
    for i in range(len(nums)):
        # Se não podemos alcançar a posição atual
        if i > max_reach:
            return False
            
        # Atualiza o alcance máximo
        max_reach = max(max_reach, i + nums[i])
        
        # Se já podemos alcançar o final
        if max_reach >= len(nums) - 1:
            return True
            
    return True
```

### **2. Gas Station (LeetCode #134)**

```python
def canCompleteCircuit(gas, cost):
    if sum(gas) < sum(cost):
        return -1  # Impossível percorrer todo o circuito
        
    start = 0
    tank = 0
    
    for i in range(len(gas)):
        tank += gas[i] - cost[i]
        
        if tank < 0:  # Não podemos chegar à próxima estação
            start = i + 1  # Tente começar da próxima
            tank = 0
            
    return start
```

## **Armadilhas Comuns em Greedy**

- **Aplicar em problemas onde não funciona**: Nem todos os problemas que parecem gulosos têm soluções gulosas ótimas
- **Não ordenar corretamente**: A ordenação errada pode levar a soluções subótimas
- **Ignorar casos extremos**: Algoritmos gulosos podem falhar em certos casos extremos
- **Não provar corretude**: Só porque parece funcionar nos exemplos não significa que seja ótimo

## **Problemas Populares no LeetCode**

| **Nome** | **ID** | **Técnica Greedy** | **Dificuldade** |
|----------|--------|---------------------|-----------------|
| Jump Game | #55 | Alcance máximo | Medium |
| Gas Station | #134 | Saldo acumulado | Medium |
| Task Scheduler | #621 | Ordenação+Prioridade | Medium |
| Non-overlapping Intervals | #435 | Ordenação+Seleção | Medium |
| Meeting Rooms II | #253 | Line Sweep | Medium |
| Partition Labels | #763 | Último índice | Medium |
| Minimum Number of Arrows to Burst Balloons | #452 | Ordenação+Seleção | Medium |

## **Dicas Ninja para Greedy**

- Tente primeiro uma solução gulosa nos problemas que envolvem otimização - são geralmente mais simples.
- Verifique se a propriedade gulosa realmente se aplica - use exemplos para testar sua intuição.
- Ordene os dados quando necessário para estabelecer prioridades claras.
- Em problemas de intervalo, geralmente é útil ordenar por fim (como no Activity Selection).
- Mantenha algum tipo de "estado global" (como max_reach, current_tank) para rastrear seu progresso.

## **Pensando Em Voz Alta: Non-overlapping Intervals**

*Problema*: Dado um conjunto de intervalos, encontre o número mínimo de intervalos que você precisa remover para fazer com que os restantes não se sobreponham.

*Insights*:
1. Ordenamos por tempo de término para maximizar o número de intervalos que podem permanecer
2. Sempre mantemos o intervalo atual com o menor tempo de término
3. Removemos qualquer intervalo que se sobreponha

```python
def eraseOverlapIntervals(intervals):
    if not intervals:
        return 0
        
    # Ordenar por tempo de término
    intervals.sort(key=lambda x: x[1])
    
    count = 0  # Número de intervalos a remover
    end = intervals[0][1]  # Fim do primeiro intervalo
    
    for i in range(1, len(intervals)):
        if intervals[i][0] < end:  # Sobreposição
            count += 1
        else:  # Sem sobreposição, atualiza o fim
            end = intervals[i][1]
            
    return count
```

## **Checklist Greedy Algorithms**

- [ ] Entendo quando um problema pode ter solução gulosa
- [ ] Sei aplicar ordenação como pré-processamento para algoritmos gulosos
- [ ] Consigo identificar a escolha gulosa correta
- [ ] Implementei pelo menos 5 soluções gulosas diferentes
- [ ] Tenho noção de como provar que um algoritmo guloso está correto

## **Mini Desafio**

**Problema:** Dado um conjunto de pessoas com habilidades diferentes (representadas como números), forme o número máximo de pares de modo que cada par tenha pelo menos uma pessoa com habilidade >= limite.

**Exemplo:** 
skills = [1, 3, 2, 5, 1, 3, 2], limite = 3
Resposta: 3 pares

**Solução**:
1. Ordene o array de habilidades
2. Use two pointers nos extremos para formar pares
3. Se skills[high] >= limite, forme um par
4. Caso contrário, tente formar um par com dois elementos menores

---

# **Estruturas Avançadas: Trie, Union Find e Segment Trees**

## **Por Que Estruturas Especializadas Fazem a Diferença**

Enquanto arrays, listas e hash maps são estruturas fundamentais, problemas complexos muitas vezes exigem estruturas de dados especializadas. As três mais importantes para entrevistas são:

- **Trie**: ótima para problemas de strings, prefixos e buscas lexicográficas
- **Union Find**: excelente para problemas de conectividade e grupos disjuntos
- **Segment Tree**: poderosa para consultas e atualizações em intervalos

Estas estruturas transformam problemas aparentemente O(n²) ou piores em soluções O(n log n) ou até O(n).

## **Trie (Árvore de Prefixos)**

A Trie é uma árvore que armazena strings de forma hierárquica, onde cada nó representa um caractere e os caminhos da raiz até qualquer nó formam um prefixo:

```
      root
     / | \
    a  b  c
   / \    |
  p   t   a
 /     \  |
p       o t
```

### **Implementação Básica**

```python
class TrieNode:
    def __init__(self):
        self.children = {}
        self.is_end_of_word = False

class Trie:
    def __init__(self):
        self.root = TrieNode()
        
    def insert(self, word):
        node = self.root
        for char in word:
            if char not in node.children:
                node.children[char] = TrieNode()
            node = node.children[char]
        node.is_end_of_word = True
        
    def search(self, word):
        node = self.root
        for char in word:
            if char not in node.children:
                return False
            node = node.children[char]
        return node.is_end_of_word
        
    def starts_with(self, prefix):
        node = self.root
        for char in prefix:
            if char not in node.children:
                return False
            node = node.children[char]
        return True
```

### **Aplicações Clássicas**

- **Implementar um autocomplete**
- **Busca por prefixo**
- **Longest common prefix**
- **Word Dictionary com operações avançadas**

### **Exemplo: Implement Trie (LeetCode #208)**

A implementação acima é basicamente a solução para este problema.

### **Exemplo: Word Search II (LeetCode #212)**

Combinando Trie com DFS para encontrar todas as palavras em uma matriz de caracteres:

```python
def findWords(board, words):
    # Constrói a trie com todas as palavras
    trie = {}
    for word in words:
        node = trie
        for c in word:
            node = node.setdefault(c, {})
        node['#'] = word  # Marca o fim da palavra
        
    rows, cols = len(board), len(board[0])
    result = []
    
    def dfs(r, c, node):
        char = board[r][c]
        
        # Char não está no trie atual
        if char not in node:
            return
            
        node = node[char]
        
        # Encontrou uma palavra completa
        if '#' in node:
            result.append(node['#'])
            del node['#']  # Evita duplicatas
            
        # Marca como visitada
        board[r][c] = '*'
        
        # Explora em todas as direções
        for dr, dc in [(0, 1), (1, 0), (0, -1), (-1, 0)]:
            nr, nc = r + dr, c + dc
            if 0 <= nr < rows and 0 <= nc < cols and board[nr][nc] != '*':
                dfs(nr, nc, node)
                
        # Restaura o caractere
        board[r][c] = char
        
        # Limpeza - remove nós sem filhos para economizar espaço
        if not node:
            del node[char]
    
    # Inicia DFS de cada célula
    for r in range(rows):
        for c in range(cols):
            dfs(r, c, trie)
            
    return result
```

## **Union Find (Disjoint Set)**

Union Find é uma estrutura especializada para rastrear conjuntos de elementos disjuntos. As operações principais são:

- **Find**: Determina a qual conjunto um elemento pertence
- **Union**: Une dois conjuntos

### **Implementação Eficiente**

```python
class UnionFind:
    def __init__(self, n):
        self.parent = list(range(n))
        self.rank = [0] * n
        self.count = n  # Número de componentes
        
    def find(self, x):
        if self.parent[x] != x:
            self.parent[x] = self.find(self.parent[x])  # Path compression
        return self.parent[x]
        
    def union(self, x, y):
        root_x = self.find(x)
        root_y = self.find(y)
        
        if root_x == root_y:
            return
            
        # Union by rank
        if self.rank[root_x] < self.rank[root_y]:
            self.parent[root_x] = root_y
        elif self.rank[root_x] > self.rank[root_y]:
            self.parent[root_y] = root_x
        else:
            self.parent[root_y] = root_x
            self.rank[root_x] += 1
            
        self.count -= 1  # Decrementar o número de componentes
```

### **Aplicações Clássicas**

- **Detectar ciclos em grafos não-direcionados**
- **Encontrar componentes conectados**
- **Kruskal's Algorithm para MST**
- **Problemas de conectividade dinâmica**

### **Exemplo: Number of Connected Components (LeetCode #323)**

```python
def countComponents(n, edges):
    uf = UnionFind(n)
    
    for x, y in edges:
        uf.union(x, y)
        
    return uf.count
```

### **Exemplo: Redundant Connection (LeetCode #684)**

```python
def findRedundantConnection(edges):
    n = len(edges)
    uf = UnionFind(n + 1)  # Nós são 1-indexados
    
    for u, v in edges:
        if uf.find(u) == uf.find(v):
            return [u, v]  # Esta aresta forma um ciclo
        uf.union(u, v)
        
    return []
```

## **Segment Tree**

Segment Tree é uma estrutura em árvore usada para consultas de intervalo eficientes (soma, mínimo, máximo, etc.) e atualizações:

### **Implementação para Range Sum Query**

```python
class SegmentTree:
    def __init__(self, nums):
        self.n = len(nums)
        # O tamanho da árvore é aproximadamente 4 * n
        self.tree = [0] * (4 * self.n)
        if self.n > 0:
            self._build(nums, 0, 0, self.n - 1)
    
    def _build(self, nums, node, start, end):
        if start == end:
            self.tree[node] = nums[start]
        else:
            mid = (start + end) // 2
            left = 2 * node + 1
            right = 2 * node + 2
            
            self._build(nums, left, start, mid)
            self._build(nums, right, mid + 1, end)
            
            self.tree[node] = self.tree[left] + self.tree[right]
    
    def update(self, index, val):
        self._update(0, 0, self.n - 1, index, val)
    
    def _update(self, node, start, end, index, val):
        if start == end:
            self.tree[node] = val
        else:
            mid = (start + end) // 2
            left = 2 * node + 1
            right = 2 * node + 2
            
            if start <= index <= mid:
                self._update(left, start, mid, index, val)
            else:
                self._update(right, mid + 1, end, index, val)
                
            self.tree[node] = self.tree[left] + self.tree[right]
    
    def query(self, left, right):
        return self._query(0, 0, self.n - 1, left, right)
    
    def _query(self, node, start, end, left, right):
        if right < start or end < left:
            return 0  # Fora do intervalo
            
        if left <= start and end <= right:
            return self.tree[node]  # Completamente dentro do intervalo
            
        # Intervalo parcialmente sobreposto
        mid = (start + end) // 2
        left_sum = self._query(2 * node + 1, start, mid, left, right)
        right_sum = self._query(2 * node + 2, mid + 1, end, left, right)
        
        return left_sum + right_sum
```

### **Aplicações Clássicas**

- **Range Sum Query**
- **Range Minimum/Maximum Query**
- **Encontrar o elemento em uma posição específica**
- **Problemas de atualização e consulta em intervalos**

### **Exemplo: Range Sum Query - Mutable (LeetCode #307)**

A implementação acima é essencialmente a solução desse problema.

## **Outras Estruturas Importantes**

### **1. Binary Indexed Tree (Fenwick Tree)**

Uma alternativa mais simples à Segment Tree para somas de prefixos:

```python
class BIT:
    def __init__(self, n):
        self.n = n
        self.tree = [0] * (n + 1)
    
    def update(self, i, val):
        while i <= self.n:
            self.tree[i] += val
            i += i & -i  # Próximo índice a atualizar
    
    def query(self, i):
        sum = 0
        while i > 0:
            sum += self.tree[i]
            i -= i & -i  # Próximo índice a consultar
        return sum
```

### **2. LRU Cache (Least Recently Used)**

Usando HashMap + Doubly Linked List para operações O(1):

```python
class LRUCache:
    class Node:
        def __init__(self, key=0, val=0):
            self.key = key
            self.val = val
            self.prev = None
            self.next = None
    
    def __init__(self, capacity):
        self.capacity = capacity
        self.cache = {}  # key -> Node
        
        # Dummy head and tail
        self.head = self.Node()
        self.tail = self.Node()
        self.head.next = self.tail
        self.tail.prev = self.head
    
    def get(self, key):
        if key not in self.cache:
            return -1
        
        # Move para o início
        node = self.cache[key]
        self._remove(node)
        self._add(node)
        
        return node.val
    
    def put(self, key, value):
        # Remove o nó existente, se houver
        if key in self.cache:
            self._remove(self.cache[key])
        
        # Cria novo nó
        node = self.Node(key, value)
        self._add(node)
        self.cache[key] = node
        
        # Remove o LRU se exceder a capacidade
        if len(self.cache) > self.capacity:
            lru = self.tail.prev
            self._remove(lru)
            del self.cache[lru.key]
    
    def _add(self, node):
        # Adiciona após o head
        node.prev = self.head
        node.next = self.head.next
        self.head.next.prev = node
        self.head.next = node
    
    def _remove(self, node):
        # Remove um nó da lista
        node.prev.next = node.next
        node.next.prev = node.prev
```

## **Problemas Populares no LeetCode**

| **Nome** | **ID** | **Estrutura** | **Dificuldade** |
|----------|--------|---------------|-----------------|
| Implement Trie | #208 | Trie | Medium |
| Word Search II | #212 | Trie + DFS | Hard |
| Number of Islands II | #305 | Union Find | Hard |
| Redundant Connection | #684 | Union Find | Medium |
| Range Sum Query - Mutable | #307 | Segment Tree | Medium |
| LRU Cache | #146 | HashMap + DLL | Medium |
| Design Add and Search Words Data Structure | #211 | Trie | Medium |
| Accounts Merge | #721 | Union Find | Medium |

## **Dicas Ninja para Estruturas Avançadas**

- **Trie**: Use quando o problema envolve prefixos, strings, ou buscas por palavra.
- **Union Find**: Ideal para problemas de conectividade dinâmica ou componentes.
- **Segment Tree**: Perfeita para consultas e atualizações de intervalos.
- **Muitos problemas "Design"** no LeetCode exigem estruturas avançadas.
- A otimização destas estruturas (compressão de caminho em Union Find, lazy propagation em Segment Tree) pode ser crucial.

## **Pensando Em Voz Alta: Design Add and Search Words**

*Problema*: Implemente uma estrutura de dados que suporte a adição de palavras e busca com wildcards ('.' representa qualquer letra).

*Insights*:
1. Usaremos uma Trie para armazenar palavras eficientemente
2. Para a busca, quando encontramos um '.', precisamos explorar todas as possibilidades
3. Podemos usar DFS recursivo para a busca com wildcards

```python
class WordDictionary:
    def __init__(self):
        self.trie = {}
        
    def addWord(self, word):
        node = self.trie
        for c in word:
            node = node.setdefault(c, {})
        node['] = True  # Marca fim da palavra
        
    def search(self, word):
        def dfs(node, i):
            if i == len(word):
                return ' in node
                
            if word[i] == '.':
                return any(dfs(node[c], i+1) for c in node if c != ')
            
            if word[i] in node:
                return dfs(node[word[i]], i+1)
                
            return False
            
        return dfs(self.trie, 0)
```

## **Checklist Estruturas Avançadas**

- [ ] Entendo a implementação básica de Trie
- [ ] Sei quando usar Union Find e como implementá-lo eficientemente
- [ ] Compreendo o funcionamento da Segment Tree para consultas de intervalo
- [ ] Apliquei pelo menos 2 destas estruturas em problemas complexos
- [ ] Conheço as otimizações para cada estrutura

## **Mini Desafio**

**Problema:** Dado um conjunto de strings, agrupe as anagramas.

**Exemplo:** 
Input: ["eat", "tea", "tan", "ate", "nat", "bat"]
Output: [["eat","tea","ate"], ["tan","nat"], ["bat"]]

**Solução**:
1. Use um HashMap para agrupar anagramas (chave = caracteres ordenados)
2. Para otimização, considere usar uma Trie onde cada nível armazena caracteres em ordem alfabética

---

# **Plano de Estudo de 12 Semanas: Da Fundação à Maestria**

Este plano de estudos é projetado para levar você da proficiência básica ao domínio completo, utilizando repetição espaçada e prática progressiva para maximizar a retenção e transferência de habilidades.

## **Semana 1: Fundamentos e Arrays**

**Foco**: Arrays, Sliding Window, Two Pointers

**Dia 1-2: Arrays Básicos**
- Easy: Two Sum (#1), Best Time to Buy and Sell Stock (#121)
- Medium: Container With Most Water (#11)

**Dia 3-4: Sliding Window**
- Easy: Maximum Subarray (#53)
- Medium: Longest Substring Without Repeating Characters (#3)

**Dia 5-6: Two Pointers**
- Easy: Valid Palindrome (#125)
- Medium: 3Sum (#15)

**Dia 7: Revisão + Desafio**
- Hard: Trapping Rain Water (#42)
- Revisão: Resolva novamente os dois problemas que achou mais difíceis

## **Semana 2: Hash Maps e Prefix Sum**

**Foco**: Hash Maps, Prefix Sum, Difference Arrays

**Dia 1-2: Hash Maps Básicos**
- Easy: Contains Duplicate (#217), Valid Anagram (#242)
- Medium: Group Anagrams (#49)

**Dia 3-4: Hash Maps Avançados**
- Medium: Subarray Sum Equals K (#560)
- Medium: Longest Consecutive Sequence (#128)

**Dia 5-6: Prefix Sum**
- Easy: Range Sum Query - Immutable (#303)
- Medium: Product of Array Except Self (#238)

**Dia 7: Revisão + Desafio**
- Hard: First Missing Positive (#41)
- Revisão Spaced: Problemas da semana 1 que você achou difíceis

## **Semana 3: Binary Search**

**Foco**: Binary Search em Arrays e no Espaço de Resposta

**Dia 1-2: Binary Search Básico**
- Easy: Binary Search (#704), First Bad Version (#278)
- Medium: Search in Rotated Sorted Array (#33)

**Dia 3-4: Binary Search em Resposta**
- Medium: Koko Eating Bananas (#875)
- Medium: Split Array Largest Sum (#410)

**Dia 5-6: Binary Search Avançado**
- Medium: Find First and Last Position (#34)
- Medium: Find Peak Element (#162)

**Dia 7: Revisão + Desafio**
- Hard: Median of Two Sorted Arrays (#4)
- Revisão Spaced: Problemas das semanas 1-2 que você achou difíceis

## **Semana 4: DFS e Backtracking I**

**Foco**: Traversal de Árvores, Backtracking Básico

**Dia 1-2: DFS em Árvores**
- Easy: Maximum Depth of Binary Tree (#104)
- Medium: Binary Tree Inorder Traversal (#94)

**Dia 3-4: DFS em Matrizes**
- Medium: Number of Islands (#200)
- Medium: Word Search (#79)

**Dia 5-6: Backtracking Básico**
- Medium: Permutations (#46)
- Medium: Subsets (#78)

**Dia 7: Revisão + Desafio**
- Hard: Word Search II (#212)
- Revisão Spaced: Problemas das semanas 1-3 conforme plano

## **Semana 5: BFS e Grafos**

**Foco**: BFS, Grafos, Shortest Path

**Dia 1-2: BFS em Árvores**
- Easy: Binary Tree Level Order Traversal (#102)
- Medium: Binary Tree Zigzag Level Order Traversal (#103)

**Dia 3-4: BFS em Matrizes**
- Medium: Rotting Oranges (#994)
- Medium: 01 Matrix (#542)

**Dia 5-6: Grafos**
- Medium: Course Schedule (#207)
- Medium: Number of Connected Components in an Undirected Graph (#323)

**Dia 7: Revisão + Desafio**
- Hard: Word Ladder (#127)
- Revisão Spaced: Problemas das semanas 1-4 conforme plano

## **Semana 6: Dynamic Programming I**

**Foco**: DP em Sequências, Tabulation

**Dia 1-2: DP Sequencial**
- Easy: Climbing Stairs (#70)
- Medium: House Robber (#198)

**Dia 3-4: DP 2D**
- Medium: Unique Paths (#62)
- Medium: Minimum Path Sum (#64)

**Dia 5-6: DP String**
- Medium: Longest Palindromic Substring (#5)
- Medium: Decode Ways (#91)

**Dia 7: Revisão + Desafio**
- Hard: Regular Expression Matching (#10)
- Revisão Spaced: Problemas mais difíceis das semanas 1-5

## **Semana 7: Dynamic Programming II**

**Foco**: DP Avançado, Memoization

**Dia 1-2: Knapsack Problems**
- Medium: Coin Change (#322)
- Medium: Partition Equal Subset Sum (#416)

**Dia 3-4: DP em Strings**
- Medium: Longest Increasing Subsequence (#300)
- Medium: Longest Common Subsequence (#1143)

**Dia 5-6: DP com Otimização**
- Hard: Edit Distance (#72)
- Medium: Jump Game (#55)

**Dia 7: Revisão + Desafio**
- Hard: Burst Balloons (#312)
- Revisão Spaced: Problemas mais difíceis das semanas 1-6

## **Semana 8: Greedy Algorithms**

**Foco**: Greedy, Intervalos, Ordenação

**Dia 1-2: Greedy Básico**
- Medium: Jump Game (#55)
- Medium: Task Scheduler (#621)

**Dia 3-4: Intervalos**
- Medium: Merge Intervals (#56)
- Medium: Non-overlapping Intervals (#435)

**Dia 5-6: Greedy Avançado**
- Medium: Gas Station (#134)
- Medium: Partition Labels (#763)

**Dia 7: Revisão + Desafio**
- Hard: Employee Free Time (#759)
- Mega Revisão: Reconstrua soluções para problemas difíceis das semanas 1-7

## **Semana 9: Estruturas Avançadas I**

**Foco**: Trie, Union Find

**Dia 1-2: Trie Básico**
- Medium: Implement Trie (#208)
- Medium: Design Add and Search Words Data Structure (#211)

**Dia 3-4: Trie Avançado**
- Hard: Word Search II (#212)
- Hard: Palindrome Pairs (#336)

**Dia 5-6: Union Find**
- Medium: Redundant Connection (#684)
- Medium: Accounts Merge (#721)

**Dia 7: Revisão + Desafio**
- Hard: Swim in Rising Water (#778)
- Revisão Spaced: Problemas das semanas 5-8

## **Semana 10: Estruturas Avançadas II**

**Foco**: Segment Tree, Binary Indexed Tree, Design

**Dia 1-2: Range Queries**
- Medium: Range Sum Query - Mutable (#307)
- Hard: Count of Smaller Numbers After Self (#315)

**Dia 3-4: LRU/LFU**
- Medium: LRU Cache (#146)
- Hard: LFU Cache (#460)

**Dia 5-6: Design Problemas**
- Medium: Design Twitter (#355)
- Medium: Design Snake Game (#353)

**Dia 7: Revisão + Desafio**
- Hard: Sliding Window Maximum (#239)
- Revisão Spaced: Problemas das semanas 5-9

## **Semana 11: Problemas de Simulação e Entrevista**

**Foco**: Mock Interviews, Problemas de Implementação

**Dia 1-2: Simulação de Entrevista 1**
- Conjunto diversificado: 1 Easy + 2 Medium

**Dia 3-4: Simulação de Entrevista 2**
- Conjunto diversificado: 1 Medium + 1 Hard

**Dia 5-6: Simulação de Entrevista 3**
- Foco em pontos fracos identificados

**Dia 7: Revisão + Desafio**
- Hard: Merge k Sorted Lists (#23)
- Revisão Spaced: Repita problemas que você continua tendo dificuldade

## **Semana 12: Consolidação e Estratégia Final**

**Foco**: Revisão de Padrões, Prática de Verbalização

**Dia 1-2: Top-20 da Meta**
- Medium/Hard: Revisão dos padrões mais comuns nas Big Tech

**Dia 3-4: Top-20 da Amazon**
- Medium/Hard: Ênfase em problemas de design e escalabilidade

**Dia 5-6: Top-20 do Google**
- Medium/Hard: Foco em problemas algorítmicos complexos

**Dia 7: Revisão Final**
- Revisão dos principais padrões e soluções
- Simulação final de entrevista
- Plano personalizado pós-guia

## **Metodologia de Estudo**

### **Para Cada Novo Problema:**

1. **Tente resolver em 25-40 minutos** sem olhar a solução
2. Se travou, revise apenas as dicas (não a solução completa)
3. Tente mais 15 minutos
4. Se ainda não conseguiu, estude a solução e entenda completamente
5. **Espere 24 horas e resolva o problema do zero**
6. **Adicione ao seu sistema de repetição espaçada**

### **Repetição Espaçada:**

- 1ª revisão: 24 horas depois
- 2ª revisão: 3 dias depois
- 3ª revisão: 7 dias depois
- 4ª revisão: 14 dias depois
- 5ª revisão: 30 dias depois

Use um sistema como Anki ou a planilha de acompanhamento abaixo para programar suas revisões.

### **Medindo Progresso:**

1. **Tempo para reconhecer o padrão**: deve diminuir com a prática
2. **Tempo para implementar**: deve se estabilizar em torno de 20-25 minutos para problemas médios
3. **Taxa de acertos na primeira tentativa**: deve aumentar gradualmente

### **Planilha de Acompanhamento:**

| ID | Problema | Padrão | Dificuldade | Data Inicial | Rev1 | Rev2 | Rev3 | Rev4 | Domínio |
|----|----------|--------|-------------|--------------|------|------|------|------|---------|
| 1  | Two Sum  | Hash   | Easy        | 01/05        | 02/05| 04/05| 08/05| 15/05| ⭐⭐⭐   |
|... |          |        |             |              |      |      |      |      |         |

---

# **150 Problemas Essenciais: O Mapa para o Domínio**

Estes 150 problemas formam um mapa completo para dominar algoritmos e estruturas de dados, cobrindo todos os padrões importantes com repetição estratégica para reforçar o aprendizado.

## **Arrays e Strings (25 problemas)**

### **Sliding Window**
1. Maximum Subarray (#53) - Easy
2. Best Time to Buy and Sell Stock (#121) - Easy
3. Longest Substring Without Repeating Characters (#3) - Medium
4. Minimum Size Subarray Sum (#209) - Medium
5. Longest Repeating Character Replacement (#424) - Medium
6. Sliding Window Maximum (#239) - Hard

### **Two Pointers**
7. Valid Palindrome (#125) - Easy
8. Two Sum II - Input array is sorted (#167) - Easy
9. Container With Most Water (#11) - Medium
10. 3Sum (#15) - Medium
11. 3Sum Closest (#16) - Medium
12. Trapping Rain Water (#42) - Hard

### **Basic Arrays**
13. Two Sum (#1) - Easy
14. Best Time to Buy and Sell Stock II (#122) - Easy
15. Product of Array Except Self (#238) - Medium
16. Find the Duplicate Number (#287) - Medium
17. First Missing Positive (#41) - Hard

### **Strings**
18. Valid Anagram (#242) - Easy
19. Valid Parentheses (#20) - Easy
20. Longest Palindromic Substring (#5) - Medium
21. Group Anagrams (#49) - Medium
22. Encode and Decode Strings (#271) - Medium
23. Minimum Window Substring (#76) - Hard
24. Basic Calculator (#224) - Hard
25. Palindrome Pairs (#336) - Hard

## **Hash Maps e Sets (15 problemas)**

26. Contains Duplicate (#217) - Easy
27. Valid Anagram (#242) - Easy
28. Group Anagrams (#49) - Medium
29. Top K Frequent Elements (#347) - Medium
30. Subarray Sum Equals K (#560) - Medium
31. Longest Consecutive Sequence (#128) - Medium
32. LRU Cache (#146) - Medium
33. Insert Delete GetRandom O(1) (#380) - Medium
34. Copy List with Random Pointer (#138) - Medium
35. Longest Substring with At Most K Distinct Characters (#340) - Medium
36. Longest Substring with At Most Two Distinct Characters (#159) - Medium
37. Find All Anagrams in a String (#438) - Medium
38. Design Twitter (#355) - Medium
39. Random Pick with Weight (#528) - Medium
40. Sudoku Solver (#37) - Hard

## **Binary Search (15 problemas)**

41. Binary Search (#704) - Easy
42. First Bad Version (#278) - Easy
43. Search Insert Position (#35) - Easy
44. Search in Rotated Sorted Array (#33) - Medium
45. Find First and Last Position of Element in Sorted Array (#34) - Medium
46. Find Peak Element (#162) - Medium
47. Search a 2D Matrix (#74) - Medium
48. Koko Eating Bananas (#875) - Medium
49. Find Minimum in Rotated Sorted Array (#153) - Medium
50. Search in Rotated Sorted Array II (#81) - Medium
51. Time Based Key-Value Store (#981) - Medium
52. Split Array Largest Sum (#410) - Hard
53. Find in Mountain Array (#1095) - Hard
54. Median of Two Sorted Arrays (#4) - Hard
55. Capacity To Ship Packages Within D Days (#1011) - Medium

## **Árvores e Grafos (30 problemas)**

### **Tree Traversal**
56. Maximum Depth of Binary Tree (#104) - Easy
57. Same Tree (#100) - Easy
58. Invert Binary Tree (#226) - Easy
59. Binary Tree Level Order Traversal (#102) - Medium
60. Binary Tree Zigzag Level Order Traversal (#103) - Medium
61. Construct Binary Tree from Preorder and Inorder Traversal (#105) - Medium
62. Validate Binary Search Tree (#98) - Medium
63. Kth Smallest Element in a BST (#230) - Medium
64. Lowest Common Ancestor of a Binary Tree (#236) - Medium
65. Binary Tree Maximum Path Sum (#124) - Hard

### **Graph Traversal**
66. Number of Islands (#200) - Medium
67. Clone Graph (#133) - Medium
68. Pacific Atlantic Water Flow (#417) - Medium
69. Course Schedule (#207) - Medium
70. Course Schedule II (#210) - Medium
71. Graph Valid Tree (#261) - Medium
72. Number of Connected Components in an Undirected Graph (#323) - Medium
73. Word Ladder (#127) - Hard
74. Alien Dictionary (#269) - Hard
75. Shortest Distance from All Buildings (#317) - Hard

### **Matrix DFS/BFS**
76. Flood Fill (#733) - Easy
77. Word Search (#79) - Medium
78. Rotting Oranges (#994) - Medium
79. Walls and Gates (#286) - Medium
80. 01 Matrix (#542) - Medium
81. Shortest Bridge (#934) - Medium
82. Word Search II (#212) - Hard
83. Making A Large Island (#827) - Hard
84. Serialize and Deserialize Binary Tree (#297) - Hard
85. Swim in Rising Water (#778) - Hard

## **Backtracking (15 problemas)**

86. Letter Combinations of a Phone Number (#17) - Medium
87. Permutations (#46) - Medium
88. Permutations II (#47) - Medium
89. Subsets (#78) - Medium
90. Subsets II (#90) - Medium
91. Combination Sum (#39) - Medium
92. Combination Sum II (#40) - Medium
93. Combination Sum III (#216) - Medium
94. Generate Parentheses (#22) - Medium
95. Palindrome Partitioning (#131) - Medium
96. Word Break (#139) - Medium
97. Restore IP Addresses (#93) - Medium
98. N-Queens (#51) - Hard
99. Sudoku Solver (#37) - Hard
100. Word Break II (#140) - Hard

## **Dynamic Programming (25 problemas)**

### **1D Dynamic Programming**
101. Climbing Stairs (#70) - Easy
102. House Robber (#198) - Medium
103. House Robber II (#213) - Medium
104. Longest Increasing Subsequence (#300) - Medium
105. Decode Ways (#91) - Medium
106. Coin Change (#322) - Medium
107. Maximum Product Subarray (#152) - Medium
108. Word Break (#139) - Medium
109. Jump Game (#55) - Medium
110. Palindromic Substrings (#647) - Medium

### **2D Dynamic Programming**
111. Unique Paths (#62) - Medium
112. Unique Paths II (#63) - Medium
113. Minimum Path Sum (#64) - Medium
114. Longest Common Subsequence (#1143) - Medium
115. Longest Palindromic Subsequence (#516) - Medium
116. Interleaving String (#97) - Medium
117. Edit Distance (#72) - Hard
118. Regular Expression Matching (#10) - Hard
119. Maximal Rectangle (#85) - Hard
120. Burst Balloons (#312) - Hard

### **Advanced DP**
121. Best Time to Buy and Sell Stock with Cooldown (#309) - Medium
122. Partition Equal Subset Sum (#416) - Medium
123. Target Sum (#494) - Medium
124. Ones and Zeroes (#474) - Medium
125. Frog Jump (#403) - Hard

## **Greedy Algorithms (10 problemas)**

126. Jump Game (#55) - Medium
127. Jump Game II (#45) - Medium
128. Gas Station (#134) - Medium
129. Task Scheduler (#621) - Medium
130. Meeting Rooms II (#253) - Medium
131. Non-overlapping Intervals (#435) - Medium
132. Merge Intervals (#56) - Medium
133. Insert Interval (#57) - Medium
134. Partition Labels (#763) - Medium
135. Queue Reconstruction by Height (#406) - Medium

## **Estruturas Avançadas (15 problemas)**

### **Trie**
136. Implement Trie (Prefix Tree) (#208) - Medium
137. Design Add and Search Words Data Structure (#211) - Medium
138. Word Search II (#212) - Hard
139. Palindrome Pairs (#336) - Hard
140. Design Search Autocomplete System (#642) - Hard

### **Union Find**
141. Number of Islands (#200) - Medium
142. Graph Valid Tree (#261) - Medium
143. Redundant Connection (#684) - Medium
144. Accounts Merge (#721) - Medium
145. Smallest String With Swaps (#1202) - Medium

### **Segment Tree / Binary Indexed Tree**
146. Range Sum Query - Mutable (#307) - Medium
147. Count of Smaller Numbers After Self (#315) - Hard
148. Sliding Window Maximum (#239) - Hard
149. The Skyline Problem (#218) - Hard
150. Count of Range Sum (#327) - Hard

---

# **Framework de Resolução: Da Leitura à Solução Otimizada**

## **O Processo de 7 Passos para Qualquer Problema**

Abaixo está um framework detalhado para resolver qualquer problema algorítmico de forma sistemática e eficiente:

### **1. Compreensão do Problema (2 minutos)**

✅ **Leia o enunciado com atenção**
- Identifique as entradas e saídas esperadas
- Anote restrições e casos especiais
- Examine os exemplos fornecidos

✅ **Faça perguntas clarificadoras**
- O que acontece com entradas vazias?
- Há suposições sobre o formato da entrada?
- Qual comportamento é esperado em casos extremos?

✅ **Reafirme o problema**
- Reformule o problema com suas próprias palavras
- Verifique se sua compreensão está correta

### **2. Análise de Exemplos (1 minuto)**

✅ **Trabalhe com os exemplos fornecidos**
- Trace o processo manualmente
- Identifique padrões ou insights

✅ **Crie seus próprios exemplos**
- Adicione casos de borda
- Tente identificar casos que violem suas suposições

✅ **Encontre contra-exemplos**
- Se você tem uma abordagem em mente, tente quebrá-la

### **3. Identificação de Padrões (2 minutos)**

✅ **Categorize o problema**
- Em que categoria esse problema se encaixa?
- Quais técnicas são comumente usadas para esse tipo de problema?

✅ **Pergunte-se:**
- Este problema envolve buscar, ordenar ou contar?
- Existe uma estrutura de dados natural para isso?
- Há subestrutura ótima (DP) ou escolhas gulosas (Greedy)?

✅ **Use a Árvore de Decisão de Técnicas**
- Se são subproblemas sobrepostos → Dynamic Programming
- Se é subsequência contígua → Sliding Window
- Se é array ordenado → Binary Search ou Two Pointers
- Se é contagem/frequência → Hash Map
- Se é grafo/matriz → DFS/BFS

### **4. Brainstorming de Abordagens (3 minutos)**

✅ **Comece com Brute Force**
- Sempre tenha uma solução básica, mesmo ineficiente
- Analise a complexidade do brute force

✅ **Refine com Técnicas Específicas**
- Aplique o padrão identificado no passo 3
- Pense em otimizações incrementais

✅ **Compare Múltiplas Soluções**
- Liste prós e contras de cada abordagem
- Análise de complexidade (tempo e espaço)

### **5. Planejamento da Solução (2 minutos)**

✅ **Defina os Passos Principais**
- Esboce o algoritmo em alto nível
- Identifique funções helpers ou subroutines

✅ **Identifique Variáveis e Estruturas**
- Quais estruturas de dados você vai precisar?
- Quais variáveis vão rastrear o estado?

✅ **Planeje em Pseudocódigo**
- Escrevendo em pseudocódigo antes de implementar

### **6. Implementação (15 minutos)**

✅ **Codifique Metodicamente**
- Siga seu pseudocódigo
- Mantenha comentários para seções complexas

✅ **Atenção a Detalhes**
- Cuidado com índices (off-by-one errors)
- Inicialize corretamente
- Verifique limites de arrays

✅ **Código Legível**
- Use nomes de variáveis significativos
- Quebre em funções quando apropriado

### **7. Verificação e Otimização (5 minutos)**

✅ **Teste com Exemplos**
- Siga o código com exemplos iniciais
- Verifique casos de borda

✅ **Encontre Bugs**
- Procure erros comuns: off-by-one, null checks, loops infinitos

✅ **Otimizações Finais**
- Há otimizações de espaço?
- Refatore para clareza
- Discuta compensações (trade-offs)

## **Árvore de Decisão para Escolha de Técnica**

Use este fluxograma para identificar rapidamente a técnica mais adequada para um problema:

```
Problema algorítmico
├── É sobre subconjuntos contíguos de array/string?
│   └── Sim → Sliding Window
├── Array está ordenado ou quase ordenado?
│   └── Sim → Binary Search ou Two Pointers
├── Envolve contagem ou frequência de elementos?
│   └── Sim → Hash Map
├── Precisa processar ranges ou intervalos?
│   └── Sim → Prefix Sum ou Difference Array
├── Tem múltiplos subproblemas sobrepostos?
│   └── Sim → Dynamic Programming
├── É sobre explorar todas as combinações possíveis?
│   └── Sim → Backtracking
├── Envolve graphs ou uma matriz 2D?
│   └── Sim
│       ├── Precisa do caminho mais curto? → BFS
│       ├── Precisa explorar tudo? → DFS
│       ├── Detectar ciclos? → Topological Sort
├── Precisa selecionar incrementalmente? 
│   └── Sim → Greedy
├── Sobre strings e prefixos?
│   └── Sim → Trie
├── Sobre componentes conectados?
│   └── Sim → Union Find
└── Sobre queries e updates em ranges?
    └── Sim → Segment Tree
```

## **Dicas de Comunicação Durante a Resolução**

Durante uma entrevista, comunicar seu pensamento é tão importante quanto resolver o problema:

### **1. Pensando Em Voz Alta**

- **Verbalize seu raciocínio**: "Vejo que este problema envolve substrings, então sliding window pode ser útil..."
- **Compartilhe intuições**: "A ordenação prévia nos permitiria usar binary search..."
- **Explique trade-offs**: "A solução hash map usa mais memória mas é O(n) vs. O(n²)..."

### **2. Comunicando Complexidade**

- **Seja preciso**: "A complexidade temporal é O(n log n) devido à ordenação inicial..."
- **Explique gargalos**: "O gargalo está no nested loop, que nos dá O(n²)..."
- **Mencione otimizações**: "Podemos reduzir para O(n) usando uma passagem única com um hash map..."

### **3. Comunicando Decisões de Design**

- **Justifique escolhas**: "Escolhi HashMap porque precisamos de lookups O(1)..."
- **Explique alternativas**: "Poderíamos usar DFS, mas BFS é mais apropriado para encontrar o caminho mais curto..."
- **Reconheça limitações**: "Esta solução funciona bem para inputs pequenos, mas para grandes datasets..."

## **Checklist de Verificação Final**

Antes de dar sua solução como finalizada, verifique:

- [ ] Sua solução funciona para todos os exemplos fornecidos?
- [ ] Você testou casos de borda (vazios, únicos, extremos)?
- [ ] A complexidade de tempo e espaço é ótima?
- [ ] Seu código está livre de bugs comuns (off-by-one, nulos, overflow)?
- [ ] Você poderia explicar sua solução para alguém não-técnico?

## **Exemplos de Análise de Problemas**

### **Exemplo 1: Maximum Subarray (Kadane's Algorithm)**

**Problema:** Encontre a subarray contígua com a maior soma.

**Pensamento em 7 passos:**

1. **Compreensão:** Precisamos da soma máxima de elementos consecutivos em um array.
2. **Exemplos:** [-2,1,-3,4,-1,2,1,-5,4] → Output: 6 (subarray [4,-1,2,1])
3. **Padrões:** É um problema de subsequência contígua → Kadane's Algorithm (variação de DP)
4. **Abordagens:**
   - Brute force: Verificar todas as subarrays O(n²)
   - Kadane's: Mantém soma atual e máxima O(n)
5. **Planejamento:**
   - Inicializar current_sum e max_sum com primeiro elemento
   - Para cada elemento, decidir se começamos nova subarray ou continuamos
6. **Implementação:**
   ```python
   def maxSubArray(nums):
       current_sum = max_sum = nums[0]
       for num in nums[1:]:
           current_sum = max(num, current_sum + num)
           max_sum = max(max_sum, current_sum)
       return max_sum
   ```
7. **Verificação:** 
   - Complexidade temporal: O(n)
   - Complexidade espacial: O(1)
   - Testado com exemplos e casos extremos

### **Exemplo 2: 3Sum**

**Problema:** Encontre todos os triplets únicos que somam zero.

**Pensamento em 7 passos:**

1. **Compreensão:** Precisamos encontrar todas as combinações únicas i,j,k onde nums[i] + nums[j] + nums[k] = 0.
2. **Exemplos:** [-1,0,1,2,-1,-4] → Output: [[-1,-1,2],[-1,0,1]]
3. **Padrões:** Problema de soma em array → Two Pointers após ordenação
4. **Abordagens:**
   - Brute force: Três loops aninhados O(n³)
   - Two pointers: Fixe um elemento e use two pointers nos restantes O(n²)
5. **Planejamento:**
   - Ordenar array
   - Para cada elemento, use two pointers nos elementos restantes
   - Pular duplicatas para evitar resultados repetidos
6. **Implementação:**
   ```python
   def threeSum(nums):
       nums.sort()
       result = []
       
       for i in range(len(nums)-2):
           if i > 0 and nums[i] == nums[i-1]:
               continue
               
           left, right = i+1, len(nums)-1
           
           while left < right:
               s = nums[i] + nums[left] + nums[right]
               
               if s < 0:
                   left += 1
               elif s > 0:
                   right -= 1
               else:
                   result.append([nums[i], nums[left], nums[right]])
                   
                   while left < right and nums[left] == nums[left+1]:
                       left += 1
                   while left < right and nums[right] == nums[right-1]:
                       right -= 1
                       
                   left += 1
                   right -= 1
                   
       return result
   ```
7. **Verificação:**
   - Complexidade temporal: O(n²)
   - Complexidade espacial: O(1) excluindo output
   - Cuidado com duplicatas
   - Teste com arrays de diferentes tamanhos

---

# **Preparação para Entrevistas: Simulação, Comunicação e Performance**

## **Além dos Algoritmos: Dominando a Entrevista**

Resolver problemas algorítmicos é apenas parte da equação. Para ter sucesso em entrevistas técnicas, você precisa:

1. **Comunicar seu pensamento claramente**
2. **Gerenciar o tempo eficientemente**
3. **Lidar com pressão e dicas**
4. **Demonstrar colaboração e receptividade**

## **Script de Comunicação para Problemas**

Use este roteiro para comunicar seu processo de solução de forma clara e estruturada:

### **1. Repetir e Clarificar (30 segundos)**

"Então, o problema pede para encontrar [objetivo]. As entradas são [entrada] e a saída esperada é [saída]. Alguns casos de borda a considerar seriam [casos vazios/extremos]. Está correto?"

### **2. Abordagem Bruta (30 segundos)**

"Vamos começar com uma abordagem bruta. Poderíamos [descreva brute force] que teria complexidade de tempo O(X) e espaço O(Y). Vamos ver se podemos melhorar isso."

### **3. Otimização e Insights (1 minuto)**

"Observo que [insight sobre o problema]. Isso sugere que podemos usar [técnica/estrutura de dados]. A ideia principal é [explique a ideia chave]."

### **4. Planejamento da Solução (1 minuto)**

"Vou abordar isso da seguinte forma:
1. Primeiro, vou [primeiro passo]
2. Depois, [segundo passo]
3. Finalmente, [passo final]

A complexidade de tempo seria O(X) e espaço O(Y)."

### **5. Durante a Implementação**

"Estou implementando [parte específica]. Aqui preciso ter cuidado com [edge case/detalhe importante]."

"Vou usar [estrutura de dados] porque [razão]."

### **6. Teste e Depuração**

"Vamos testar com o exemplo: [trace o exemplo]"

"Hmm, encontrei um problema em [X]. Vou corrigir isso [explicação da correção]."

### **7. Análise Final**

"A solução tem complexidade de tempo O(X) devido a [razão] e espaço O(Y) porque [explicação]. Um trade-off é [mencione algum trade-off]."

## **Simulação de Entrevista em 45 Minutos**

| Tempo | Atividade | Dicas |
|-------|-----------|-------|
| 0-5 min | Clarificação do problema | Faça perguntas, anote restrições |
| 5-10 min | Brainstorming e abordagem | Discuta múltiplas ideias, analyze complexidade |
| 10-25 min | Implementação | Pense em voz alta, estruture seu código |
| 25-35 min | Testes e debugging | Teste meticulosamente, comece com exemplos simples |
| 35-40 min | Otimização e discussão | Discuta possíveis melhorias |
| 40-45 min | Perguntas e follow-ups | Pergunte sobre extensões do problema |

## **Estratégias para Lidar com Bloqueios**

Quando você emperrar durante uma entrevista, use estas técnicas:

### **1. Volte aos Básicos**

"Vamos revisar os requisitos novamente e garantir que entendi corretamente."

### **2. Examine Exemplos Novamente**

"Deixe-me trabalhar com um exemplo simples para ver se posso identificar algum padrão."

### **3. Pense em Voz Alta**

"Estou considerando usar [técnica], mas estou preocupado com [problema potencial]."

### **4. Abordagem Sistemática**

"Vamos tentar categorizar este problema. Parece um problema de [categoria], que geralmente pode ser resolvido com [técnica]."

### **5. Pedir Dicas de Forma Inteligente**

"Estou pensando em duas direções: [opção A] ou [opção B]. Você tem alguma sugestão sobre qual pode ser mais promissora?"

## **Recebendo Feedback Durante a Entrevista**

### **Sinais Positivos:**
- O entrevistador pergunta sobre otimizações
- Pede para implementar uma solução mais eficiente
- Faz perguntas de follow-up relacionadas
- Pede para explicar a complexidade

### **Sinais de Alerta:**
- Perguntas direcionadas para uma técnica específica
- Sugestões repetidas sobre a mesma coisa
- Perguntas se você conhece uma estrutura de dados específica
- Dicas sobre como simplificar o problema

## **Simulando Entrevistas Reais**

Para maximizar seu preparo:

1. **Use plataformas de mock interview**:
   - Pramp, interviewing.io, LeetCode Mock
   - Peça a amigos para entrevistar você

2. **Grave suas sessões de prática**:
   - Revise seu comportamento e comunicação
   - Identifique padrões de problemas

3. **Simule ambientes de pressão**:
   - Pratique com timer
   - Alterne entre diferentes tipos de problemas

4. **Feedback estruturado**:
   - Peça feedback específico sobre comunicação
   - Avalie tanto a solução quanto o processo

## **Checklist Pré-Entrevista**

- [ ] Revisei os padrões principais (Sliding Window, DP, Graphs, etc.)
- [ ] Pratiquei problemas da empresa alvo
- [ ] Fiz pelo menos 5 entrevistas simuladas
- [ ] Tenho respostas preparadas para bloqueios comuns
- [ ] Testei meu ambiente (se for entrevista remota)
- [ ] Tenho papel/quadro para diagramas (se necessário)
- [ ] Revisei meu próprio código de problemas difíceis
- [ ] Preparei 2-3 perguntas para o entrevistador

## **Preparação Específica por Empresa**

### **Google**
- Foco: Algoritmos puros, eficiência de código
- Particularidades: Problemas originais, múltiplas soluções
- Dica: Pratique edge cases exaustivamente

### **Meta (Facebook)**
- Foco: Arrays, strings, grafos
- Particularidades: Problemas práticos, escalabilidade
- Dica: Comunique claramente, valorize otimizações

### **Amazon**
- Foco: Design orientado a objeto, problemas práticos
- Particularidades: Perguntas baseadas em seus princípios de liderança
- Dica: Relacione problemas a cenários reais

### **Microsoft**
- Foco: Arrays, árvores, design
- Particularidades: Problemas incrementais, discussão colaborativa
- Dica: Demonstre processo de pensamento e colaboração

## **Palavras Finais**

Lembre-se que o objetivo de entrevistas técnicas não é apenas verificar se você conhece algoritmos, mas também:

1. **Como você pensa** e aborda problemas
2. **Como você se comunica** e colabora
3. **Como você lida com feedback** e pressão
4. **Se você seria um bom colega** de equipe

A prática consistente com o framework deste guia irá desenvolver não apenas suas habilidades técnicas, mas também sua confiança e capacidade de demonstrar seu melhor durante entrevistas.

**Boa sorte em sua jornada de mastery do LeetCode!**